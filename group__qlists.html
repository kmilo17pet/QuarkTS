<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="QuarkTS OS" />
<meta property="og:image" content="https://github.com/kmilo17pet/QuarkTS/raw/master/doc/quarktslogo.png" />
<meta property="og:description" content="An open-source OS for small embedded applications." />
<meta property="og:url" content="https://kmilo17pet.github.io/QuarkTS/" />
<!-- END opengraph metadata -->
<!-- BEGIN twitter metadata -->
<meta name="twitter:image:src" content="https://github.com/kmilo17pet/QuarkTS/raw/master/doc/quarktslogo.png" />
<meta name="twitter:title" content="QuarkTS OS" />
<meta name="twitter:description" content="An open-source OS for small embedded applications." />
<!-- END twitter metadata -->
<title>OS: Generic double-linked lists</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/svg+xml" href="logo.drawio.svg"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/kmilo17pet/QuarkTS" class="github-corner" title="View source on GitHub" target="_blank" rel="noopener noreferrer">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="quarktslogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OS
   &#160;<span id="projectnumber">v7.3.3</span>
   </div>
   <div id="projectbrief">Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__qlists.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Generic double-linked lists<div class="ingroups"><a class="el" href="group__qutility.html">Utilities</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The provided list implementation uses a generic doubly-linked approach in which each node, apart from storing its data, has two link pointers. The first link points to the previous node in the list and the second link, points to the next node in the list. The first node of the list has its previous link pointing to <code>NULL</code>, similarly, the last node of the list has its next node pointing to <code>NULL</code>.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Generic double-linked lists:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__qlists.svg" width="270" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structq_list___node__t.html">qList_Node_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list-node object (Used internally)  <a href="structq_list___node__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structq_list__t.html">qList_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list object (Generic double-linked)  <a href="structq_list__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structq_list___for_each_handle__t.html">qList_ForEachHandle_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle of the <a class="el" href="#ga7e23b95be4ccdf58913c83b4c989545a" title="Operate on each element of the list.">qList_ForEach()</a> API that is passed as an argument to the function that operates on each node.  <a href="structq_list___for_each_handle__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structq_list___compare_handle__t.html">qList_CompareHandle_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle of the <a class="el" href="#ga0fc519c838d1b95729829aeabc2c30d6" title="Sort the double linked list using the f function to determine the order. The sorting algorithm used b...">qList_Sort()</a> API that is passed as an argument to the compare function.  <a href="structq_list___compare_handle__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structq_list___iterator__t.html">qList_Iterator_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to hold a list-iterator instance.  <a href="structq_list___iterator__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga4e8a2d40891d2463b41fcf02ce482d11" id="r_ga4e8a2d40891d2463b41fcf02ce482d11"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4e8a2d40891d2463b41fcf02ce482d11">qNode_MinimalFields</a></td></tr>
<tr class="memdesc:ga4e8a2d40891d2463b41fcf02ce482d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro can be used to create custom data that can be used as node of a list. User should locate this macro as the first member of the custom structure.  <br /></td></tr>
<tr class="separator:ga4e8a2d40891d2463b41fcf02ce482d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0281056dbf82517b975635ed7553498e" id="r_ga0281056dbf82517b975635ed7553498e"><td class="memItemLeft" align="right" valign="top"><a id="ga0281056dbf82517b975635ed7553498e" name="ga0281056dbf82517b975635ed7553498e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>QLIST_INITIALIZER</b></td></tr>
<tr class="memdesc:ga0281056dbf82517b975635ed7553498e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro can be used to initialize empty lists. <br /></td></tr>
<tr class="separator:ga0281056dbf82517b975635ed7553498e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ac10e1f970071083e544b5943c2cb12" id="r_ga4ac10e1f970071083e544b5943c2cb12"><td class="memItemLeft" align="right" valign="top"><a id="ga4ac10e1f970071083e544b5943c2cb12" name="ga4ac10e1f970071083e544b5943c2cb12"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>QLIST_AT_FRONT</b></td></tr>
<tr class="memdesc:ga4ac10e1f970071083e544b5943c2cb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro should be used to define the destination position of a node in front of a list. <br /></td></tr>
<tr class="separator:ga4ac10e1f970071083e544b5943c2cb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf97560f5644785364d4fa39252a565b" id="r_gadf97560f5644785364d4fa39252a565b"><td class="memItemLeft" align="right" valign="top"><a id="gadf97560f5644785364d4fa39252a565b" name="gadf97560f5644785364d4fa39252a565b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>QLIST_AT_BACK</b></td></tr>
<tr class="memdesc:gadf97560f5644785364d4fa39252a565b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro should be used to define the destination position of a node at the end of a list. <br /></td></tr>
<tr class="separator:gadf97560f5644785364d4fa39252a565b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5365ab050c7da9fb0b835f48d042ad61" id="r_ga5365ab050c7da9fb0b835f48d042ad61"><td class="memItemLeft" align="right" valign="top"><a id="ga5365ab050c7da9fb0b835f48d042ad61" name="ga5365ab050c7da9fb0b835f48d042ad61"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>QLIST_FORWARD</b></td></tr>
<tr class="memdesc:ga5365ab050c7da9fb0b835f48d042ad61"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro should be used to define the direction of travel of the list forward. <br /></td></tr>
<tr class="separator:ga5365ab050c7da9fb0b835f48d042ad61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2446c3162503fa5f1a078fbbd2519fab" id="r_ga2446c3162503fa5f1a078fbbd2519fab"><td class="memItemLeft" align="right" valign="top"><a id="ga2446c3162503fa5f1a078fbbd2519fab" name="ga2446c3162503fa5f1a078fbbd2519fab"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>QLIST_BACKWARD</b></td></tr>
<tr class="memdesc:ga2446c3162503fa5f1a078fbbd2519fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro should be used to define the direction of travel of the list backwards. <br /></td></tr>
<tr class="separator:ga2446c3162503fa5f1a078fbbd2519fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad42c79d2d75a2cdfa3fb15043561f836" id="r_gad42c79d2d75a2cdfa3fb15043561f836"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad42c79d2d75a2cdfa3fb15043561f836">qList_NodeFcn_t</a>) (<a class="el" href="structq_list___for_each_handle__t.html">qList_ForEachHandle_t</a> h)</td></tr>
<tr class="memdesc:gad42c79d2d75a2cdfa3fb15043561f836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a function that operates on every node when using the <a class="el" href="#ga7e23b95be4ccdf58913c83b4c989545a" title="Operate on each element of the list.">qList_ForEach()</a> API.  <br /></td></tr>
<tr class="separator:gad42c79d2d75a2cdfa3fb15043561f836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ac18ce58031e0c1a42b7bb5f06cca35" id="r_ga0ac18ce58031e0c1a42b7bb5f06cca35"><td class="memItemLeft" align="right" valign="top"><a id="ga0ac18ce58031e0c1a42b7bb5f06cca35" name="ga0ac18ce58031e0c1a42b7bb5f06cca35"></a>
typedef <a class="el" href="group__qtypes.html#ga7d9daac1f82c727d47bc07e9d9cc98fe">qINT32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>qList_Position_t</b></td></tr>
<tr class="memdesc:ga0ac18ce58031e0c1a42b7bb5f06cca35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to hold the target position of a node in a list. <br /></td></tr>
<tr class="separator:ga0ac18ce58031e0c1a42b7bb5f06cca35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3728aea0a10627dc0fde9024f73bf2a7" id="r_ga3728aea0a10627dc0fde9024f73bf2a7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3728aea0a10627dc0fde9024f73bf2a7">qList_CompareFcn_t</a>) (<a class="el" href="structq_list___compare_handle__t.html">qList_CompareHandle_t</a> h)</td></tr>
<tr class="memdesc:ga3728aea0a10627dc0fde9024f73bf2a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a function used by the <a class="el" href="#ga0fc519c838d1b95729829aeabc2c30d6" title="Sort the double linked list using the f function to determine the order. The sorting algorithm used b...">qList_Sort()</a> API to compare nodes of a list.  <br /></td></tr>
<tr class="separator:ga3728aea0a10627dc0fde9024f73bf2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82ff0fa88da708f27f31269ba556ed1c" id="r_ga82ff0fa88da708f27f31269ba556ed1c"><td class="memItemLeft" align="right" valign="top"><a id="ga82ff0fa88da708f27f31269ba556ed1c" name="ga82ff0fa88da708f27f31269ba556ed1c"></a>
typedef <a class="el" href="structq_list___node__t.html">qList_Node_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><b>qList_Direction_t</b>) (const <a class="el" href="structq_list___node__t.html">qList_Node_t</a> *const node)</td></tr>
<tr class="memdesc:ga82ff0fa88da708f27f31269ba556ed1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to hold the direction in which the list should be traversed. <br /></td></tr>
<tr class="separator:ga82ff0fa88da708f27f31269ba556ed1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac443200e204bccbc22937ce7eb140d13" id="r_gac443200e204bccbc22937ce7eb140d13"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac443200e204bccbc22937ce7eb140d13">qList_WalkStage_t</a> { <a class="el" href="#ggac443200e204bccbc22937ce7eb140d13aa8a99051d458ad07f2dd1cc1bb40cecf">qList_WalkInit</a>
, <a class="el" href="#ggac443200e204bccbc22937ce7eb140d13af3b5f4482bbd10704c784367a859d3b4">qList_WalkThrough</a>
, <a class="el" href="#ggac443200e204bccbc22937ce7eb140d13a338bec07126aae0ca34578cd06c53161">qList_WalkEnd</a>
 }</td></tr>
<tr class="memdesc:gac443200e204bccbc22937ce7eb140d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum to describe the ForEach stage.  <a href="#gac443200e204bccbc22937ce7eb140d13">More...</a><br /></td></tr>
<tr class="separator:gac443200e204bccbc22937ce7eb140d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga86e322fc08445521defa394a234f6d64" id="r_ga86e322fc08445521defa394a234f6d64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga86e322fc08445521defa394a234f6d64">qList_Initialize</a> (<a class="el" href="structq_list__t.html">qList_t</a> *const l)</td></tr>
<tr class="memdesc:ga86e322fc08445521defa394a234f6d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be called before a list is used. This initialises all the members of the list structure.  <br /></td></tr>
<tr class="separator:ga86e322fc08445521defa394a234f6d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fbd27183cfdb3c07d7c5a64b4cc6a5e" id="r_ga4fbd27183cfdb3c07d7c5a64b4cc6a5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4fbd27183cfdb3c07d7c5a64b4cc6a5e">qList_Insert</a> (<a class="el" href="structq_list__t.html">qList_t</a> *const l, void *const node, const <a class="el" href="#ga0ac18ce58031e0c1a42b7bb5f06cca35">qList_Position_t</a> p)</td></tr>
<tr class="memdesc:ga4fbd27183cfdb3c07d7c5a64b4cc6a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an item into the list.  <br /></td></tr>
<tr class="separator:ga4fbd27183cfdb3c07d7c5a64b4cc6a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c76510b8cc482f0c0f571970846a11a" id="r_ga0c76510b8cc482f0c0f571970846a11a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0c76510b8cc482f0c0f571970846a11a">qList_RemoveItself</a> (void *const node)</td></tr>
<tr class="memdesc:ga0c76510b8cc482f0c0f571970846a11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the node is member of a list, the node will be removed from it.  <br /></td></tr>
<tr class="separator:ga0c76510b8cc482f0c0f571970846a11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32fefe5679f8b066b224b66725609fca" id="r_ga32fefe5679f8b066b224b66725609fca"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga32fefe5679f8b066b224b66725609fca">qList_Remove</a> (<a class="el" href="structq_list__t.html">qList_t</a> *const l, void *const node, const <a class="el" href="#ga0ac18ce58031e0c1a42b7bb5f06cca35">qList_Position_t</a> p)</td></tr>
<tr class="memdesc:ga32fefe5679f8b066b224b66725609fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an item from the list.  <br /></td></tr>
<tr class="separator:ga32fefe5679f8b066b224b66725609fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0592661bc81be625f30fda047f3ee3cc" id="r_ga0592661bc81be625f30fda047f3ee3cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0592661bc81be625f30fda047f3ee3cc">qList_Move</a> (<a class="el" href="structq_list__t.html">qList_t</a> *const dst, <a class="el" href="structq_list__t.html">qList_t</a> *const src, const <a class="el" href="#ga0ac18ce58031e0c1a42b7bb5f06cca35">qList_Position_t</a> p)</td></tr>
<tr class="memdesc:ga0592661bc81be625f30fda047f3ee3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves(or merge) the entire list pointed by <em class="arg">src</em> to the list pointed by <em class="arg">dst</em> at location specified by <em class="arg">p</em>. After the move operation, this function leaves empty the list pointed by <em class="arg">src</em>.  <br /></td></tr>
<tr class="separator:ga0592661bc81be625f30fda047f3ee3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42241f8b14311e3ffebc0b152438d99c" id="r_ga42241f8b14311e3ffebc0b152438d99c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga42241f8b14311e3ffebc0b152438d99c">qList_IsMember</a> (const <a class="el" href="structq_list__t.html">qList_t</a> *const l, const void *const node)</td></tr>
<tr class="memdesc:ga42241f8b14311e3ffebc0b152438d99c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the node is member of the list.  <br /></td></tr>
<tr class="separator:ga42241f8b14311e3ffebc0b152438d99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e01746c7d0272c0cf92b1ae0407ee82" id="r_ga8e01746c7d0272c0cf92b1ae0407ee82"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8e01746c7d0272c0cf92b1ae0407ee82">qList_GetFront</a> (const <a class="el" href="structq_list__t.html">qList_t</a> *const l)</td></tr>
<tr class="memdesc:ga8e01746c7d0272c0cf92b1ae0407ee82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the front item of the list.  <br /></td></tr>
<tr class="separator:ga8e01746c7d0272c0cf92b1ae0407ee82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33ff3975cd04ca2adf64edcb85efaf24" id="r_ga33ff3975cd04ca2adf64edcb85efaf24"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga33ff3975cd04ca2adf64edcb85efaf24">qList_GetBack</a> (const <a class="el" href="structq_list__t.html">qList_t</a> *const l)</td></tr>
<tr class="memdesc:ga33ff3975cd04ca2adf64edcb85efaf24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the back item of the list.  <br /></td></tr>
<tr class="separator:ga33ff3975cd04ca2adf64edcb85efaf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24887aa23cbe2670c5d84220e21d940a" id="r_ga24887aa23cbe2670c5d84220e21d940a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga24887aa23cbe2670c5d84220e21d940a">qList_IsEmpty</a> (const <a class="el" href="structq_list__t.html">qList_t</a> *const l)</td></tr>
<tr class="memdesc:ga24887aa23cbe2670c5d84220e21d940a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the list is empty.  <br /></td></tr>
<tr class="separator:ga24887aa23cbe2670c5d84220e21d940a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee39a44dcd8d634e952a1bac2ede929e" id="r_gaee39a44dcd8d634e952a1bac2ede929e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaee39a44dcd8d634e952a1bac2ede929e">qList_Length</a> (const <a class="el" href="structq_list__t.html">qList_t</a> *const l)</td></tr>
<tr class="memdesc:gaee39a44dcd8d634e952a1bac2ede929e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of items inside the list.  <br /></td></tr>
<tr class="separator:gaee39a44dcd8d634e952a1bac2ede929e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fc519c838d1b95729829aeabc2c30d6" id="r_ga0fc519c838d1b95729829aeabc2c30d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0fc519c838d1b95729829aeabc2c30d6">qList_Sort</a> (<a class="el" href="structq_list__t.html">qList_t</a> *const l, <a class="el" href="#ga3728aea0a10627dc0fde9024f73bf2a7">qList_CompareFcn_t</a> f)</td></tr>
<tr class="memdesc:ga0fc519c838d1b95729829aeabc2c30d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the double linked list using the <em class="arg">f</em> function to determine the order. The sorting algorithm used by this function compares pairs of adjacent nodes by calling the specified <em class="arg">f</em> function with pointers to them as arguments. The sort is performed only modifying node's links without data swapping, improving performance if nodes have a large storage.  <br /></td></tr>
<tr class="separator:ga0fc519c838d1b95729829aeabc2c30d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c8b83b1b7766c1471b3212e9e94126d" id="r_ga5c8b83b1b7766c1471b3212e9e94126d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5c8b83b1b7766c1471b3212e9e94126d">qList_IteratorSet</a> (<a class="el" href="structq_list___iterator__t.html">qList_Iterator_t</a> *i, <a class="el" href="structq_list__t.html">qList_t</a> *const l, void *nodeOffset, const <a class="el" href="#ga82ff0fa88da708f27f31269ba556ed1c">qList_Direction_t</a> d)</td></tr>
<tr class="memdesc:ga5c8b83b1b7766c1471b3212e9e94126d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup an instance of the given iterator to traverse the list.  <br /></td></tr>
<tr class="separator:ga5c8b83b1b7766c1471b3212e9e94126d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e23b95be4ccdf58913c83b4c989545a" id="r_ga7e23b95be4ccdf58913c83b4c989545a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7e23b95be4ccdf58913c83b4c989545a">qList_ForEach</a> (const <a class="el" href="structq_list__t.html">qList_t</a> *const l, const <a class="el" href="#gad42c79d2d75a2cdfa3fb15043561f836">qList_NodeFcn_t</a> f, void *arg, <a class="el" href="#ga82ff0fa88da708f27f31269ba556ed1c">qList_Direction_t</a> d, void *nodeOffset)</td></tr>
<tr class="memdesc:ga7e23b95be4ccdf58913c83b4c989545a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operate on each element of the list.  <br /></td></tr>
<tr class="separator:ga7e23b95be4ccdf58913c83b4c989545a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75f82f140bbf2911d7c445329c0d9020" id="r_ga75f82f140bbf2911d7c445329c0d9020"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga75f82f140bbf2911d7c445329c0d9020">qList_Swap</a> (void *node1, void *node2)</td></tr>
<tr class="memdesc:ga75f82f140bbf2911d7c445329c0d9020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two nodes that belongs to the same list by changing its own links.  <br /></td></tr>
<tr class="separator:ga75f82f140bbf2911d7c445329c0d9020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1f1c5e25f2a11332afb041be466ad2a" id="r_gad1f1c5e25f2a11332afb041be466ad2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structq_list___iterator__t.html">qList_Iterator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad1f1c5e25f2a11332afb041be466ad2a">qList_Begin</a> (<a class="el" href="structq_list__t.html">qList_t</a> *const xList)</td></tr>
<tr class="memdesc:gad1f1c5e25f2a11332afb041be466ad2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the list container.  <br /></td></tr>
<tr class="separator:gad1f1c5e25f2a11332afb041be466ad2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f359a3f7408a63be1cdbc91a5319dc8" id="r_ga1f359a3f7408a63be1cdbc91a5319dc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structq_list___iterator__t.html">qList_Iterator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1f359a3f7408a63be1cdbc91a5319dc8">qList_End</a> (<a class="el" href="structq_list__t.html">qList_t</a> *const xList)</td></tr>
<tr class="memdesc:ga1f359a3f7408a63be1cdbc91a5319dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the last element in the list container.  <br /></td></tr>
<tr class="separator:ga1f359a3f7408a63be1cdbc91a5319dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14403e854f0f4cdb3a0cd0d1fc6eb97a" id="r_ga14403e854f0f4cdb3a0cd0d1fc6eb97a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga14403e854f0f4cdb3a0cd0d1fc6eb97a">qListIterator_Until</a> (const <a class="el" href="structq_list___iterator__t.html">qList_Iterator_t</a> *const i, const void *const node)</td></tr>
<tr class="memdesc:ga14403e854f0f4cdb3a0cd0d1fc6eb97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check until current iterator reach the given node.  <br /></td></tr>
<tr class="separator:ga14403e854f0f4cdb3a0cd0d1fc6eb97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaced3d38798da58f037121b3ecf28d0e7" id="r_gaced3d38798da58f037121b3ecf28d0e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaced3d38798da58f037121b3ecf28d0e7">qListIterator_Forward</a> (<a class="el" href="structq_list___iterator__t.html">qList_Iterator_t</a> *i)</td></tr>
<tr class="memdesc:gaced3d38798da58f037121b3ecf28d0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the iterator forward.  <br /></td></tr>
<tr class="separator:gaced3d38798da58f037121b3ecf28d0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7af314c957fbeaeef2ec9186cdbfe28a" id="r_ga7af314c957fbeaeef2ec9186cdbfe28a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7af314c957fbeaeef2ec9186cdbfe28a">qListIterator_Backward</a> (<a class="el" href="structq_list___iterator__t.html">qList_Iterator_t</a> *i)</td></tr>
<tr class="memdesc:ga7af314c957fbeaeef2ec9186cdbfe28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the iterator backward.  <br /></td></tr>
<tr class="separator:ga7af314c957fbeaeef2ec9186cdbfe28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b27b4b74780fa4b163e6e6e3cbac062" id="r_ga2b27b4b74780fa4b163e6e6e3cbac062"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2b27b4b74780fa4b163e6e6e3cbac062">qListIterator_Get</a> (const <a class="el" href="structq_list___iterator__t.html">qList_Iterator_t</a> *const i)</td></tr>
<tr class="memdesc:ga2b27b4b74780fa4b163e6e6e3cbac062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the node that the iterator is currently pointing to.  <br /></td></tr>
<tr class="separator:ga2b27b4b74780fa4b163e6e6e3cbac062"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The provided list implementation uses a generic doubly-linked approach in which each node, apart from storing its data, has two link pointers. The first link points to the previous node in the list and the second link, points to the next node in the list. The first node of the list has its previous link pointing to <code>NULL</code>, similarly, the last node of the list has its next node pointing to <code>NULL</code>. </p>
<p>The list data-structure, referenced through an object of type <a class="el" href="structq_list__t.html" title="A list object (Generic double-linked)">qList_t</a> also has a head and a tail pointer, to allow fast operations on boundary nodes.</p>
<p>Nodes should be an user-defined data structure of any number of members, however, they must be specially defined to be compatible with the provided APIs. All the user-defined nodes must have the <a class="el" href="#ga4e8a2d40891d2463b41fcf02ce482d11" title="This macro can be used to create custom data that can be used as node of a list. User should locate t...">qNode_MinimalFields</a> definition on top of the structure. An example is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <a class="code hl_define" href="#ga4e8a2d40891d2463b41fcf02ce482d11">qNode_MinimalFields</a>;</div>
<div class="line">    <span class="keywordtype">int</span> a;</div>
<div class="line">    <span class="keywordtype">int</span> b;</div>
<div class="line">    <span class="keywordtype">float</span> y;</div>
<div class="line">} userdata_t;</div>
<div class="ttc" id="agroup__qlists_html_ga4e8a2d40891d2463b41fcf02ce482d11"><div class="ttname"><a href="#ga4e8a2d40891d2463b41fcf02ce482d11">qNode_MinimalFields</a></div><div class="ttdeci">#define qNode_MinimalFields</div><div class="ttdoc">This macro can be used to create custom data that can be used as node of a list. User should locate t...</div><div class="ttdef"><b>Definition</b> qlists.h:79</div></div>
</div><!-- fragment --><p>With this special type definition on all custom data, the application writer can take advantage of this versatile data structure. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga4e8a2d40891d2463b41fcf02ce482d11" name="ga4e8a2d40891d2463b41fcf02ce482d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e8a2d40891d2463b41fcf02ce482d11">&#9670;&#160;</a></span>qNode_MinimalFields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define qNode_MinimalFields</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro can be used to create custom data that can be used as node of a list. User should locate this macro as the first member of the custom structure. </p>
<p>Example : </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">      <a class="code hl_define" href="#ga4e8a2d40891d2463b41fcf02ce482d11">qNode_MinimalFields</a>;</div>
<div class="line">      <span class="keywordtype">int</span> x;</div>
<div class="line">      <span class="keywordtype">float</span> y;</div>
<div class="line">      <span class="keywordtype">char</span> str[ 10 ];</div>
<div class="line">} mydata_t;</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga3728aea0a10627dc0fde9024f73bf2a7" name="ga3728aea0a10627dc0fde9024f73bf2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3728aea0a10627dc0fde9024f73bf2a7">&#9670;&#160;</a></span>qList_CompareFcn_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>(* qList_CompareFcn_t) (<a class="el" href="structq_list___compare_handle__t.html">qList_CompareHandle_t</a> h)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to a function used by the <a class="el" href="#ga0fc519c838d1b95729829aeabc2c30d6" title="Sort the double linked list using the f function to determine the order. The sorting algorithm used b...">qList_Sort()</a> API to compare nodes of a list. </p>
<p>Example : </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> myNode_CompareFcn( <a class="code hl_struct" href="structq_list___compare_handle__t.html">qList_CompareHandle_t</a> h ) {</div>
<div class="line">      mydata_t *n1 = (mydata_t *)h-&gt;<a class="code hl_variable" href="structq_list___compare_handle__t.html#a3448184cc3864a59ca4757a9d3a3da0d">n1</a>;</div>
<div class="line">      mydata_t *n2 = (mydata_t *)h-&gt;n2;</div>
<div class="line">      <span class="keywordflow">return</span> (<a class="code hl_typedef" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>)( n1-&gt;x &gt; n2-&gt;x );</div>
<div class="line">}</div>
<div class="ttc" id="agroup__qtypes_html_ga131b2258b5135d0b1e3ded5ecbe309d7"><div class="ttname"><a href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a></div><div class="ttdeci">qUINT8_t qBool_t</div><div class="ttdoc">A type to instantiate an OS boolean variable.</div><div class="ttdef"><b>Definition</b> qtypes.h:139</div></div>
<div class="ttc" id="astructq_list___compare_handle__t_html"><div class="ttname"><a href="structq_list___compare_handle__t.html">qList_CompareHandle_t</a></div><div class="ttdoc">Handle of the qList_Sort() API that is passed as an argument to the compare function.</div><div class="ttdef"><b>Definition</b> qlists.h:133</div></div>
<div class="ttc" id="astructq_list___compare_handle__t_html_a3448184cc3864a59ca4757a9d3a3da0d"><div class="ttname"><a href="structq_list___compare_handle__t.html#a3448184cc3864a59ca4757a9d3a3da0d">qList_CompareHandle_t::n1</a></div><div class="ttdeci">const void * n1</div><div class="ttdef"><b>Definition</b> qlists.h:134</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>The handler object containing the objects being compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> value indicates that element pointed by <em class="arg">node1</em> goes after the element pointed to by <em class="arg">node2</em> </dd></dl>

</div>
</div>
<a id="gad42c79d2d75a2cdfa3fb15043561f836" name="gad42c79d2d75a2cdfa3fb15043561f836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad42c79d2d75a2cdfa3fb15043561f836">&#9670;&#160;</a></span>qList_NodeFcn_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>(* qList_NodeFcn_t) (<a class="el" href="structq_list___for_each_handle__t.html">qList_ForEachHandle_t</a> h)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to a function that operates on every node when using the <a class="el" href="#ga7e23b95be4ccdf58913c83b4c989545a" title="Operate on each element of the list.">qList_ForEach()</a> API. </p>
<p>Example : </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> ForEach_ListExample( <a class="code hl_struct" href="structq_list___for_each_handle__t.html">qList_ForEachHandle_t</a> h ) {</div>
<div class="line">      <span class="keywordflow">if</span> ( <a class="code hl_enumvalue" href="#ggac443200e204bccbc22937ce7eb140d13af3b5f4482bbd10704c784367a859d3b4">qList_WalkThrough</a> == h-&gt;<a class="code hl_variable" href="structq_list___for_each_handle__t.html#a3a0029b84cc61be4b552d11e6770fb6f">stage</a> ) {</div>
<div class="line"> </div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code hl_enumvalue" href="#ggac443200e204bccbc22937ce7eb140d13aa8a99051d458ad07f2dd1cc1bb40cecf">qList_WalkInit</a> == h-&gt;<a class="code hl_variable" href="structq_list___for_each_handle__t.html#a3a0029b84cc61be4b552d11e6770fb6f">stage</a> ) {</div>
<div class="line"> </div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code hl_enumvalue" href="#ggac443200e204bccbc22937ce7eb140d13a338bec07126aae0ca34578cd06c53161">qList_WalkEnd</a> == h-&gt;<a class="code hl_variable" href="structq_list___for_each_handle__t.html#a3a0029b84cc61be4b552d11e6770fb6f">stage</a> ) {</div>
<div class="line"> </div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span> {</div>
<div class="line"> </div>
<div class="line">      }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__qlists_html_ggac443200e204bccbc22937ce7eb140d13a338bec07126aae0ca34578cd06c53161"><div class="ttname"><a href="#ggac443200e204bccbc22937ce7eb140d13a338bec07126aae0ca34578cd06c53161">qList_WalkEnd</a></div><div class="ttdeci">@ qList_WalkEnd</div><div class="ttdef"><b>Definition</b> qlists.h:105</div></div>
<div class="ttc" id="agroup__qlists_html_ggac443200e204bccbc22937ce7eb140d13aa8a99051d458ad07f2dd1cc1bb40cecf"><div class="ttname"><a href="#ggac443200e204bccbc22937ce7eb140d13aa8a99051d458ad07f2dd1cc1bb40cecf">qList_WalkInit</a></div><div class="ttdeci">@ qList_WalkInit</div><div class="ttdef"><b>Definition</b> qlists.h:103</div></div>
<div class="ttc" id="agroup__qlists_html_ggac443200e204bccbc22937ce7eb140d13af3b5f4482bbd10704c784367a859d3b4"><div class="ttname"><a href="#ggac443200e204bccbc22937ce7eb140d13af3b5f4482bbd10704c784367a859d3b4">qList_WalkThrough</a></div><div class="ttdeci">@ qList_WalkThrough</div><div class="ttdef"><b>Definition</b> qlists.h:104</div></div>
<div class="ttc" id="astructq_list___for_each_handle__t_html"><div class="ttname"><a href="structq_list___for_each_handle__t.html">qList_ForEachHandle_t</a></div><div class="ttdoc">Handle of the qList_ForEach() API that is passed as an argument to the function that operates on each...</div><div class="ttdef"><b>Definition</b> qlists.h:115</div></div>
<div class="ttc" id="astructq_list___for_each_handle__t_html_a3a0029b84cc61be4b552d11e6770fb6f"><div class="ttname"><a href="structq_list___for_each_handle__t.html#a3a0029b84cc61be4b552d11e6770fb6f">qList_ForEachHandle_t::stage</a></div><div class="ttdeci">qList_WalkStage_t stage</div><div class="ttdef"><b>Definition</b> qlists.h:118</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>A handle to the list iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value that can be used to continue or break the walk through loop over the list. If a <a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> value its returned the break will be performed </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gac443200e204bccbc22937ce7eb140d13" name="gac443200e204bccbc22937ce7eb140d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac443200e204bccbc22937ce7eb140d13">&#9670;&#160;</a></span>qList_WalkStage_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gac443200e204bccbc22937ce7eb140d13">qList_WalkStage_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An enum to describe the ForEach stage. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac443200e204bccbc22937ce7eb140d13aa8a99051d458ad07f2dd1cc1bb40cecf" name="ggac443200e204bccbc22937ce7eb140d13aa8a99051d458ad07f2dd1cc1bb40cecf"></a>qList_WalkInit&#160;</td><td class="fielddoc"><p>When the loop is about to start. In this case, A <code>NULL</code> value will be passed in the node pointer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac443200e204bccbc22937ce7eb140d13af3b5f4482bbd10704c784367a859d3b4" name="ggac443200e204bccbc22937ce7eb140d13af3b5f4482bbd10704c784367a859d3b4"></a>qList_WalkThrough&#160;</td><td class="fielddoc"><p>When the loop is traversing the list. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac443200e204bccbc22937ce7eb140d13a338bec07126aae0ca34578cd06c53161" name="ggac443200e204bccbc22937ce7eb140d13a338bec07126aae0ca34578cd06c53161"></a>qList_WalkEnd&#160;</td><td class="fielddoc"><p>When the loop has finished. In this case, A <code>NULL</code> value will be passed in the node pointer. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad1f1c5e25f2a11332afb041be466ad2a" name="gad1f1c5e25f2a11332afb041be466ad2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1f1c5e25f2a11332afb041be466ad2a">&#9670;&#160;</a></span>qList_Begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structq_list___iterator__t.html">qList_Iterator_t</a> qList_Begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_list__t.html">qList_t</a> *const</td>          <td class="paramname"><span class="paramname"><em>xList</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element in the list container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xList</td><td>Pointer to the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the beginning of the sequence container. </dd></dl>

</div>
</div>
<a id="ga1f359a3f7408a63be1cdbc91a5319dc8" name="ga1f359a3f7408a63be1cdbc91a5319dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f359a3f7408a63be1cdbc91a5319dc8">&#9670;&#160;</a></span>qList_End()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structq_list___iterator__t.html">qList_Iterator_t</a> qList_End </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_list__t.html">qList_t</a> *const</td>          <td class="paramname"><span class="paramname"><em>xList</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the last element in the list container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xList</td><td>Pointer to the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the latest item of the sequence container. </dd></dl>

</div>
</div>
<a id="ga7e23b95be4ccdf58913c83b4c989545a" name="ga7e23b95be4ccdf58913c83b4c989545a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e23b95be4ccdf58913c83b4c989545a">&#9670;&#160;</a></span>qList_ForEach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qList_ForEach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structq_list__t.html">qList_t</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#gad42c79d2d75a2cdfa3fb15043561f836">qList_NodeFcn_t</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga82ff0fa88da708f27f31269ba556ed1c">qList_Direction_t</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>nodeOffset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operate on each element of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>Pointer to the list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The function to perform over the node. Should have this prototype: <div class="fragment"><div class="line"><a class="code hl_typedef" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> Function( <a class="code hl_struct" href="structq_list___for_each_handle__t.html">qList_ForEachHandle_t</a> h ) </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<p>If <em class="arg">f</em> returns <a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a>, the walk-through loop will be terminated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Argument passed to <em class="arg">f</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>Direction. Use one of the following options: <a class="el" href="#ga5365ab050c7da9fb0b835f48d042ad61" title="This macro should be used to define the direction of travel of the list forward.">QLIST_FORWARD</a> or <a class="el" href="#ga2446c3162503fa5f1a078fbbd2519fab" title="This macro should be used to define the direction of travel of the list backwards.">QLIST_BACKWARD</a>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nodeOffset</td><td>If available, the list walk through will start from this node. To ignore, pass <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> if the walk through was early terminated, otherwise returns <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a>. </dd></dl>

</div>
</div>
<a id="ga33ff3975cd04ca2adf64edcb85efaf24" name="ga33ff3975cd04ca2adf64edcb85efaf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33ff3975cd04ca2adf64edcb85efaf24">&#9670;&#160;</a></span>qList_GetBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * qList_GetBack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structq_list__t.html">qList_t</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the back item of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>Pointer to the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the back node. <code>NULL</code> if the list is empty </dd></dl>

</div>
</div>
<a id="ga8e01746c7d0272c0cf92b1ae0407ee82" name="ga8e01746c7d0272c0cf92b1ae0407ee82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e01746c7d0272c0cf92b1ae0407ee82">&#9670;&#160;</a></span>qList_GetFront()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * qList_GetFront </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structq_list__t.html">qList_t</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the front item of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>Pointer to the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the front node. <code>NULL</code> if the list is empty </dd></dl>

</div>
</div>
<a id="ga86e322fc08445521defa394a234f6d64" name="ga86e322fc08445521defa394a234f6d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86e322fc08445521defa394a234f6d64">&#9670;&#160;</a></span>qList_Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qList_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_list__t.html">qList_t</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Must be called before a list is used. This initialises all the members of the list structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>Pointer to the list being initialised. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> on success, <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a> otherwise. </dd></dl>

</div>
</div>
<a id="ga4fbd27183cfdb3c07d7c5a64b4cc6a5e" name="ga4fbd27183cfdb3c07d7c5a64b4cc6a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fbd27183cfdb3c07d7c5a64b4cc6a5e">&#9670;&#160;</a></span>qList_Insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qList_Insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_list__t.html">qList_t</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ga0ac18ce58031e0c1a42b7bb5f06cca35">qList_Position_t</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an item into the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>Pointer to the list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>A pointer to the node to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The position where the node will be inserted. Could be #QLIST_ATFRONT, #QLIST_ATBACK or any other index number where the node will be inserted after. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> if the item was successfully added to the list, otherwise returns <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a> </dd></dl>

</div>
</div>
<a id="ga24887aa23cbe2670c5d84220e21d940a" name="ga24887aa23cbe2670c5d84220e21d940a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24887aa23cbe2670c5d84220e21d940a">&#9670;&#160;</a></span>qList_IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qList_IsEmpty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structq_list__t.html">qList_t</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the list is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>Pointer to the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> if the list is empty, <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a> if it is not. </dd></dl>

</div>
</div>
<a id="ga42241f8b14311e3ffebc0b152438d99c" name="ga42241f8b14311e3ffebc0b152438d99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42241f8b14311e3ffebc0b152438d99c">&#9670;&#160;</a></span>qList_IsMember()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qList_IsMember </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structq_list__t.html">qList_t</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *const</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the node is member of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>Pointer to the list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>A pointer to the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> if the node belongs to the list, <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a> if it is not. </dd></dl>

</div>
</div>
<a id="ga5c8b83b1b7766c1471b3212e9e94126d" name="ga5c8b83b1b7766c1471b3212e9e94126d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c8b83b1b7766c1471b3212e9e94126d">&#9670;&#160;</a></span>qList_IteratorSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qList_IteratorSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_list___iterator__t.html">qList_Iterator_t</a> *</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structq_list__t.html">qList_t</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>nodeOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ga82ff0fa88da708f27f31269ba556ed1c">qList_Direction_t</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup an instance of the given iterator to traverse the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Pointer to the iterator instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>Pointer to the list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeOffset</td><td>The start offset-node. To ignore, pass <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>Use one of the following options: <a class="el" href="#ga5365ab050c7da9fb0b835f48d042ad61" title="This macro should be used to define the direction of travel of the list forward.">QLIST_FORWARD</a> or <a class="el" href="#ga2446c3162503fa5f1a078fbbd2519fab" title="This macro should be used to define the direction of travel of the list backwards.">QLIST_BACKWARD</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> on success. Otherwise returns <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a>. </dd></dl>

</div>
</div>
<a id="gaee39a44dcd8d634e952a1bac2ede929e" name="gaee39a44dcd8d634e952a1bac2ede929e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee39a44dcd8d634e952a1bac2ede929e">&#9670;&#160;</a></span>qList_Length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t qList_Length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structq_list__t.html">qList_t</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of items inside the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>Pointer to the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of items of the list. </dd></dl>

</div>
</div>
<a id="ga0592661bc81be625f30fda047f3ee3cc" name="ga0592661bc81be625f30fda047f3ee3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0592661bc81be625f30fda047f3ee3cc">&#9670;&#160;</a></span>qList_Move()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qList_Move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_list__t.html">qList_t</a> *const</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structq_list__t.html">qList_t</a> *const</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ga0ac18ce58031e0c1a42b7bb5f06cca35">qList_Position_t</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves(or merge) the entire list pointed by <em class="arg">src</em> to the list pointed by <em class="arg">dst</em> at location specified by <em class="arg">p</em>. After the move operation, this function leaves empty the list pointed by <em class="arg">src</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dst</td><td>Pointer to the list where the <em class="arg">src</em> nodes are to be moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Pointer to the source list to be moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The position where <em class="arg">src</em> list will be inserted. Could be #QLIST_ATFRONT, #QLIST_ATBACK or any other index number where the list will be inserted after. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> if the move operation is performed successfully, otherwise returns <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a> </dd></dl>

</div>
</div>
<a id="ga32fefe5679f8b066b224b66725609fca" name="ga32fefe5679f8b066b224b66725609fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32fefe5679f8b066b224b66725609fca">&#9670;&#160;</a></span>qList_Remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * qList_Remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_list__t.html">qList_t</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ga0ac18ce58031e0c1a42b7bb5f06cca35">qList_Position_t</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an item from the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>Pointer to the list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>A pointer to the node to be deleted (to ignore pass <code>NULL</code> ). If the node is member or the list, use <a class="el" href="#ga0c76510b8cc482f0c0f571970846a11a" title="If the node is member of a list, the node will be removed from it.">qList_RemoveItself()</a> to avoid overhead </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The position of the node that will be removed. Could be #QLIST_ATFRONT, #QLIST_ATBACK or any other index number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the removed node. <code>NULL</code> if removal can't be performed. </dd></dl>

</div>
</div>
<a id="ga0c76510b8cc482f0c0f571970846a11a" name="ga0c76510b8cc482f0c0f571970846a11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c76510b8cc482f0c0f571970846a11a">&#9670;&#160;</a></span>qList_RemoveItself()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qList_RemoveItself </td>
          <td>(</td>
          <td class="paramtype">void *const</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the node is member of a list, the node will be removed from it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>A pointer to the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> on Success. <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a> if removal can't be performed. </dd></dl>

</div>
</div>
<a id="ga0fc519c838d1b95729829aeabc2c30d6" name="ga0fc519c838d1b95729829aeabc2c30d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fc519c838d1b95729829aeabc2c30d6">&#9670;&#160;</a></span>qList_Sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qList_Sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_list__t.html">qList_t</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga3728aea0a10627dc0fde9024f73bf2a7">qList_CompareFcn_t</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort the double linked list using the <em class="arg">f</em> function to determine the order. The sorting algorithm used by this function compares pairs of adjacent nodes by calling the specified <em class="arg">f</em> function with pointers to them as arguments. The sort is performed only modifying node's links without data swapping, improving performance if nodes have a large storage. </p>
<dl class="section note"><dt>Note</dt><dd>The function modifies the content of the list by reordering its elements as defined by <em class="arg">f</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>Pointer to the list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Pointer to a function that compares two nodes. This function is called repeatedly by <a class="el" href="#ga0fc519c838d1b95729829aeabc2c30d6" title="Sort the double linked list using the f function to determine the order. The sorting algorithm used b...">qList_Sort()</a> to compare two nodes. It shall follow the following prototype: <div class="fragment"><div class="line"><a class="code hl_typedef" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> CompareFcn( <a class="code hl_struct" href="structq_list___compare_handle__t.html">qList_CompareHandle_t</a> h ) </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<p>The function defines the order of the elements by returning a Boolean data, where a <a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> value indicates that element pointed by <em class="arg">node1</em> goes after the element pointed to by <em class="arg">node2</em>. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> if at least one reordering is performed over the list. </dd></dl>

</div>
</div>
<a id="ga75f82f140bbf2911d7c445329c0d9020" name="ga75f82f140bbf2911d7c445329c0d9020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75f82f140bbf2911d7c445329c0d9020">&#9670;&#160;</a></span>qList_Swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qList_Swap </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>node1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>node2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap two nodes that belongs to the same list by changing its own links. </p>
<dl class="section note"><dt>Note</dt><dd>The list containing nodes will be updated if any node is part of the boundaries. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node1</td><td>Pointer to the first node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node2</td><td>Pointer to the second node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> if the swap operation is performed. Otherwise returns <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a>. </dd></dl>

</div>
</div>
<a id="ga7af314c957fbeaeef2ec9186cdbfe28a" name="ga7af314c957fbeaeef2ec9186cdbfe28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7af314c957fbeaeef2ec9186cdbfe28a">&#9670;&#160;</a></span>qListIterator_Backward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qListIterator_Backward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_list___iterator__t.html">qList_Iterator_t</a> *</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move the iterator backward. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Pointer to the iterator instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaced3d38798da58f037121b3ecf28d0e7" name="gaced3d38798da58f037121b3ecf28d0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaced3d38798da58f037121b3ecf28d0e7">&#9670;&#160;</a></span>qListIterator_Forward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qListIterator_Forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_list___iterator__t.html">qList_Iterator_t</a> *</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move the iterator forward. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Pointer to the iterator instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2b27b4b74780fa4b163e6e6e3cbac062" name="ga2b27b4b74780fa4b163e6e6e3cbac062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b27b4b74780fa4b163e6e6e3cbac062">&#9670;&#160;</a></span>qListIterator_Get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * qListIterator_Get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structq_list___iterator__t.html">qList_Iterator_t</a> *const</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the node that the iterator is currently pointing to. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node currently being pointed. </dd></dl>

</div>
</div>
<a id="ga14403e854f0f4cdb3a0cd0d1fc6eb97a" name="ga14403e854f0f4cdb3a0cd0d1fc6eb97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14403e854f0f4cdb3a0cd0d1fc6eb97a">&#9670;&#160;</a></span>qListIterator_Until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qListIterator_Until </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structq_list___iterator__t.html">qList_Iterator_t</a> *const</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *const</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check until current iterator reach the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Pointer to the iterator instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>A pointer to the node you want to reach. To ignore pass <code>NULL</code> as argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> if the iterator has reach the given node. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
