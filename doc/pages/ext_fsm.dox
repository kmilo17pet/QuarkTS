/*! @page q_fsm Finite State Machines (FSM)
* @tableofcontents
*
* @section q_fsm_overview Overview
* The state machine is one of the fundamental programming patterns that are 
* most commonly used. This approach breaks down the design into a series of 
* finite steps called "states" that perform some narrowly defined actions. 
* Every state can change to another as a consequence of incoming stimuli also 
* called events or signals. This elemental mechanism allows designers to solve 
* complex engineering problems in a very straightforward way. Knowing the 
* importance of this approach in the development of embedded applications, 
* the OS adopts this design pattern as a kernel extension.
*
* In an effort to maximize efficiency and minimize complexity, the extension 
* implements the basic features of the Harel statecharts to represent
* hierarchical state machines. This features form a proper subset that 
* approaches in a very minimalist way, some of the specifications of the 
* UML statecharts, including:
*
* - Nested states with proper handling of group transitions and group reactions.
* - Guaranteed execution of entry/exit actions upon entering/exiting states.
* - Straightforward transitions and guards.
*
* In addition to this, the provided implementation also features a powerful 
* coding abstraction including transition tables and timeout signals, allowing 
* to build scalable solutions from simple flat state-machines to complex 
* statecharts.
* 
* @section qfsm_approach The provided approach
* In QuarkTS, a state-machine must be instantiated with an object of type qSM_t.
* States are represented as instances of the qSM_State_t object.
*
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>fsmdesign</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-18T18:10:14.990Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;Pus0kYQw-gJYphxEF1EV\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;64UyDokTRLeBllNpieF3\&quot; name=\&quot;P치gina-1\&quot;&gt;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&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>FSM module design</em>
* </center>
*
* One important attribute of the qSM_State_t object is the callback function, 
* which is used to describe the behavior specific to the state. Also there is a 
* pointer to the parent state to define nesting of the state and its place in 
* the hierarchical topology. As shown in figure above, a state machine consist 
* of a least one state, the "top level" state. So concrete state machine are 
* built by adding an arbitrary number states and defining callback functions.
* The only purpose of the top state is to provide the root of the hierarchy, so 
* that the highest level can return to top as their parent state.
*
* @section q_fsmsetup Setting up a state machine
* Like any other OS object, a Finite State Machine (FSM) must be explicitly 
* initialized before it can be used. The qStateMachine_Setup() API initializes 
* the instance, sets the callback for the top state, sets the initial state and 
* the surrounding callback function.
*
* @section q_fsm_subscribe_states Subscribing states and defining callbacks
* State machines are constructed by composition, therefore, the topology of a 
* state machine is determined upon construction. In this FSM implementation, 
* there are not distinction between composite states(states containing substates) 
* and leaf states. All states are potentially composite. The API 
* qStateMachine_StateSubscribe() should be used to initialize the state and 
* define its position in the topology. 
*
* A state callback-functions takes a qSM_Handler_t object as input argument and
* returns a @ref qSM_Status_t value. An example is shown in the following code snippet:
*
*  @code{.c}
*  qSM_Status_t ExampleState_Callback( qSM_Handler_t h ) {
*      /* TODO: State code */
*      return qSM_STATUS_EXIT_SUCCESS;
*  }
*  @endcode
*
* @section q_fsmhandler The state callback handler: performing transitions and retreiving data
* Because callback functions are methods derived from the state-machine object, 
* they have direct access to some attributes via the qSM_Handler_t argument. 
* The usage of this object it's required to make the FSM moves between states 
* and additionally get extra data. The provided attributes are:
*
* - qSM_Handler_t::NextState : Desired next state. The application writer should 
* change this field to another state to produce a state transition in the next 
* FSM's cycle. Changing this field will only take effect when the state is 
* executed under user custom-defined signals or in the absence of signals 
* #QSM_SIGNAL_NONE.
* - qSM_Handler_t::StartState : Desired nested initial state (substate). The 
* application writer should change this field to set the initial transition if
* the current state its a parent(or composite state). Changing this field 
* attribute only take effect when the state is executed under the 
* #QSM_SIGNAL_START signal. 
* - qSM_Handler_t::Signal (read-only) : Received signal. Can have any of the 
* following values:
*     - #QSM_SIGNAL_NONE if no signal available.
*     - #QSM_SIGNAL_ENTRY if the current state has just entered from another state.
*     - #QSM_SIGNAL_START to set nested initial transitions by using the 
*       qSM_Handler_t::StartState attribute.
*     - #QSM_SIGNAL_EXIT if the current state has just exit to another state.
*     - Any other user-defined signal will reside here, including the 
*     #QSM_SIGNAL_TIMEOUT signals.
* - qSM_Handler_t::SignalData (read-only) : Pointer to the data associated with
* the signal. For internal signals, including timeout signals, its value will 
* be @c NULL.
* - qSM_Handler_t::TransitionHistory : Use this option if the transition is to 
* a composite state. This attribute defines how the story should be handled. 
* If this field is not established, ::qSM_TRANSITION_NO_HISTORY is assumed. 
* The possible values for this attribute are:
*     - ::qSM_TRANSITION_NO_HISTORY : History is not preserved. Composite states 
*       will start according to their default transition.
*     - ::qSM_TRANSITION_SHALLOW_HISTORY : History will be kept to allow the 
*       return to only the top-most sub-state of the most recent state 
*       configuration, which is entered using the default entry rule.
*     - ::qSM_TRANSITION_DEEP_HISTORY : History will be kept to allow full state
*       configuration of the most recent visit to the containing region.
* - qSM_Handler_t::Status (read-only) :  The exit(or return) status of the last 
* state. Should be used in the Surrounding callback to perform the corresponding
* actions for every value. On states callback will take the value ::qSM_STATUS_NULL
* - qSM_Handler_t::machine (read-only) : A generic pointer to the container 
* state machine.
* - qSM_Handler_t::Data (read-only) : State-machine associated data. If the FSM
* is running as a task, the associated event data can be queried through this 
* field. (here, a cast to qEvent_t is mandatory).
* - qSM_Handler_t::StateData (read-only) : State associated data. Storage-pointer.
*
* Within the callback function of every state, only one level of dispatching 
* (based on the signal) is necessary. Typically this is archived using a 
* single-level switch statement. Callback functions communicate with the state 
* machine engine through the qSM_Handler_t and the return value of type 
* @ref qSM_Status_t.
*
* The semantic is simple, if a signal is processed, the callback functions 
* returns the status value ::qSM_STATUS_SIGNAL_HANDLED. otherwise it throws the
* signal for further processing by higher-level states. Also, this returning
* mechanism can be used to handle exceptions by using the surrounding callback.
*
* @a Entry/Exit actions and default transitions are also implemented inside the
* callback function in response of pre-defined signals. #QSM_SIGNAL_ENTRY, 
* #QSM_SIGNAL_EXIT and #QSM_SIGNAL_START. The state machine generates and 
* dispatches this signals to appropriates handlers upon  state transitions.
*
* The example below shows what a status callback should look like including the 
* use of the handler.
*
*  @code{.c}
*  qSM_Status_t ExampleState_Callback ( qSM_Handler_t h ) {
*      switch ( h->Signal ) {
*          case QSM_SIGNAL_START:
*              break;
*          case QSM_SIGNAL_ENTRY:
*              break;
*          case QSM_SIGNAL_EXIT:
*              break;
*          case USER_DEFINED_SIGNAL :
*              h->NextState = &OtherState; /*transition*/
*              break;
*          default:
*              break;
*      }
*      return qSM_STATUS_EXIT_SUCCESS;
*  }
*  @endcode 
*
* As shown above, the return value represents the exit status of the state, and 
* it can be handled with an additional surrounding callback function \f$ S_u \f$ 
* established at the moment of the FSM setup. The values allowed to return are
* listed below.
*
* - ::qSM_STATUS_EXIT_SUCCESS
* - ::qSM_STATUS_EXIT_FAILURE
* - ::qSM_STATUS_SIGNAL_HANDLED
* - Any other integer value between @c -32762 and @c 32767
*
* To code initial transitions, application writer should catch the 
* #QSM_SIGNAL_START, perform the required actions and then designate the target 
* sub-state by assigning the @c StartState attribute of the qSM_Handler_t 
* argument. Regular transitions are coded in a very similar  way, except that 
* here, you catch the custom-defined signal and then assign the @c NextState
* attribute of the qSM_Handler_t argument. The developer is free to write and 
* control state transitions. Transitions are only allowed under the availability
* of user custom-defined signals. Regular transitions are not allowed at an 
* entry point (#QSM_SIGNAL_ENTRY), exit point (#QSM_SIGNAL_EXIT), or a start 
* point (#QSM_SIGNAL_START).
*
* @note User should not target the top state in a transition and use it as 
* transition source either. The only customizable aspect of the top state is 
* the initial transition.
*
* @section q_fsm_surrounding The surrounding callback
* It is a checkpoint before and after each state executes its activities 
* through its state callback. The behavior of this surrounding callback must be 
* defined by the programmer.
*
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>surrounding</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-19T05:34:37.293Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;poDBqKg0qx6tawrUZqnR\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;4V9vBTZxQXj7jBstcZzX\&quot; name=\&quot;P치gina-1\&quot;&gt;7Zpdb6M4FIZ/TS7HMgaDuWzSdEejdlRttZqdq5ULboLGwZEx+dhfvzYxgWDSyc6kKbuTpFLx8fd5H7CPycifLDa/SbqcP4iU8RGC6Wbk344Q8iCO9D9j2VpLDHeGmcxSa2oMT9nfrK5prWWWsuKgoBKCq2x5aExEnrNEHdiolGJ9WOxF8MNel3TGHMNTQrlr/ZKlam6tXhg3GR9ZNpvbrgmyE17QurCdSTGnqVi3TP505E+kEGp3tdhMGDfOq/2yq3d3JHc/MMlydUqFh+jz/GG6Wtze/5X+8eUTI58W+INtZUV5aSdsB6u2tQekKPOUmUbgyB+v55liT0uamNy11lzb5mrBdcrTl4WS4hubCC5kVduPq4/Oeck4r+25yJkxiVzd0UXGDRsfGV8xlSV030rtb+2pcUqLeTUG04kdM5OKbY46w9u7WLPJxIIpudVFbIUwhICQXa2aTIz8nWHdCK15BZ71ybwlc00xtXjN9j00CugLK8K/EAQ5gjw6iuhmNP7s+2pw+sz4mCbfZpWIXfdrRZ5sq4XgZliHktyXSZZS3fdE5LpALZm9ST1s0y21CTTfPg4gjO7u7nq1bZOhS04mU1yVrPqy4/POoHmEESCoo7nvA0Qc2QMMfM9VPfABjN5IeN8R/mmEQq6My8pnfTkzl2Vt0320zP8LRDo5ryAyDc33DRAhKNwrPDxEgisi749IGBG9csD9xxsqLbhvJXFoGaGxdwWmtSFpWDn/riOGROvdsDPYxSg8iZ0PV3IuRU4IIYDwP0BO5JAzKWU1yy4U2hnKcXxL6Y6J8myW62Si22LaPjb+1OECv7EZiyxNK8kLjVeWz+7Zi5lv0Fh+ty4wJqGrv/AqHpvriky3MF6KLFeVQ/BY/+kt/gQCPMJ6tBOd9pq0/jPFpTKgKUmzSkVGC7VmhZmVFIoq+lzNtYKoDv68Vxg8Gg8dhmAukGfZHMMOUgQ6PGFvHzS1eUIQIPxGPBGHpzF7EZLd5NsrUYMmKozM1L7LVBhcnKm4b3WDkqlS5iNziqKXP98zjtkVuXI2ZM6IFwEUnABaDLzIBc1/q5Oc+gSzhdlnA86VpkHTRHyAg+PhXQ9YcQzCCz/BPPfc9lGyVSbK4srXoPnCelV0DiEHApV79uxGcnl6Y96qGEA4LYosOQzg+jzYewpc62SKJaVc7YMl1+vas3L7py1bJb6aBMB18nbTzrzd2tRu8Cx1XvB0tEJQUTlj6hXXBP2atrfG0BWrtknGqcpWh8Pok8/28Gjuj9ZGKghA90wSBwCTw4YKUcqE2brt90Dd5kLS11zsxftPp+Wde5yWK8j23vgJ7tyj70Fwdyo/78UFjsIeKqJGRvyDgMBuKGjwQJdlwj3rHgQTA3gWofdkLkI+6K5e56EuwhHwm2bCbuioeyEeviyE7hH6LwHhu8EVE4De5plGUARI0wzqYfjidLmH7L8EXSc84vB7UkjMDj0+HgGeB0jdAcCwAXIAPLpH9wAAB8lrOHm2cLL1bgqd6T0RDrrr5pE3Qz33DwpBhI7fLUdiS51sfsO2Y7H5JaA//Qc=&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>Surrounding callback invocation after and before the current state</em>
* </center>
*
* The surrounding callback \f$ S_u \f$ invocation occurs after and before the
* current state \f$ P \f$. When the surrounding callback is executed, indicates 
* its own checkpoint through the @c Status attribute of the qSM_Handler_t 
* argument.
* Unlike a state callback, the surrounding callback should not return anything, 
* thus, the callback should be written as:
*
*  @code{.c}
*  void SurroundingCallback_Example( qSM_Handler_t h ) {
*      switch ( h->Status ) {
*          case qSM_STATUS_BEFORE_ANY:
*              /* TODO: before any code */
*              break;
*          case qSM_STATUS_EXIT_FAILURE:
*              /* TODO: failure code */
*              break;
*          case qSM_STATUS_EXIT_SUCCESS:
*              /* TODO: success code */
*              break;
*          case qSM_STATUS_SIGNAL_HANDLED:
*              /* TODO: signal handled code */
*              break;
*          case 5: /*user defined return value*/
*              /* TODO: used defined*/
*              break;
*          default:
*              /*handle the unexpected*/
*              break
*      }
*  }
*  @endcode 
*
* As you can see in the example below, the surrounding execution case its 
* verified through the FSM handle by reading the @c Status field.
*
* @section q_fsm_astask Adding a state machine as a task
* The best strategy to run a FSM is delegating it to a task. For this, the 
* qOS_Add_StateMachineTask() API should be used. Here, the task does not have 
* a specific callback, instead, it will evaluate the active state of the FSM, 
* and later, all the other possible states in response to events that mark 
* their own transition. The task will be scheduled to run every @c t seconds in
* #qPeriodic mode.
*
* By using this API, the kernel will take care of the FSM by itself, so the
* usage of qStateMachine_Run()  can be omitted.
* 
* Now that a task is running a dedicated state-machine, the specific task 
* event-information can be obtained in every state callback through the @c Data
* field of the qSM_Handler_t argument.
*
* Check the example below:
*
*  @code{.c}
*  qSM_Status_t Example_State( qSM_Handler_t h ) {
*      qEvent_t e = h->Data; 
*      /* Get the event info of the task that owns this state-machine*/
*      switch ( h->Signal ) {
*          case QSM_SIGNAL_ENTRY:
*              break;
*          case QSM_SIGNAL_EXIT:
*              break;
*          default:
*              switch ( e->Trigger ) {
*                  case byTimeElapsed:
*                      /* TODO: Code for this case */
*                  break;
*                  case byNotificationSimple:
*                      /* TODO: Code for this case */
*                  break;
*                  case byQueueCount:
*                      /* TODO: Code for this case */
*                  break;
*                  default: break;
*              }
*              /* TODO: State code */
*              break;
*      }
*      return qSM_STATUS_EXIT_SUCCESS;
*  }
*  @endcode 
*
* @section q_fsm_example1 A demonstrative example for a FSM 
* In this example, one press of the button turn on the LED, a second push of 
* the button will make the LED blink and if the button is pressed again, the 
* LED will turn off. Also, our system must turn off the LED after a period of 
* inactivity. If the button hasn't been pressed in the last 10 seconds, the 
* LED will turn off.
* 
* <center>
* @htmlonly
* <html>
* <head>
* <title>fsmled</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;zoom&quot;:1.2,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-19T16:44:19.377Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;2qA6oxdCwsuBkRDcJq6T\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;rT_7VhNZph5krCK22-1H\&quot; name=\&quot;P치gina-1\&quot;&gt;7VrbUts6FP2azLQPeOSr5Edyg85wgDacOfSJMbGSaOpYqaJA0q+vZEuOLZtgKAk9TAgD1pa0tb0vS0t2Om5vvj5j0WL2D41x0nFAvO64/Y7j2J4fin9SssklfpC3p4zEasxWMCK/sBICJV2RGC8rAzmlCSeLqnBM0xSPeUUWMUYfq8MmNKmuuoimuCYYjaOkLv2PxHympHYQbjvOMZnO1NLIgXnHPNKD1Z0sZ1FMH0sid9Bxe4xSnl/N1z2cSN9pv+Tzhk/0FoYxnPI2E06cL+TXl68L1D2/+upfuPAyuD6xvVzNQ5Ss1B13nCARCrsTKvQ6wVRea9m9FlxNJlomVrw3xwlZdXrmAL7RXmV0lcZYGgZE9+OMcDxaRGPZ+yjSSMhmfJ6Ili0ul5zRH7hHE8qy2S4C8iNNJElSkg8C+VGmD6M5SWTOnePkAXMyjgpVOpCOGtqkWrkFM47XTzrcLsIo0h/TOeZsI4aoCVDn8EbXAkC54LGUSUANmpWSSKdMpJJ3WujexldcqBC/JNx+U7ijufR4er9cNIVa3K1cuSHY7mkxmJUyoKKuO7q+uxj0766Gw0+fD5QKKU2xmQUXqzGJI7F0j6ZLKhdvSIYoIdNUXCd4oitAIZINDp0rTstc8faWK8EroSE9IsMz0UbIiLbrO7VoO4dFBvhuyHCpgOG5CT9HN2SO2d0I808d6QjVnf/loo+uRGKJ+wc2sIDYoMARcV6Qg7BlDu4PcdDrEKebkPTHEXSeC7jjGVsMBPWAw4OCTnho0Hk1hjQortplrhTjSbSSQ5qtasrVynwykQZqe4cM42+rtMHme5n8YkxuNLD8yefMaDEQtgDVssKnRRqrb67Ozi4GLfG6A/tH7G1ZimHLUkT7KkVd45VSNII3XrGHLHZ2VofxqTxfi+Y4iZZLMq4Grxrp4vALWoSqbSRq+QEAHA6HjcHGa8Jv5fqWr1rflTXyur8uNza6IaHmttzI5liOr9vbeVlLT8w9h+PaowUjQYR36YqN8S6IVJnCIzbF/FkCV0+5Ukb5DQmlZQwnEScPVYObskytcE2J3FB1RofAYBMO9C2/qiW/VzWx/KDC0GUD11Bm+zVluT9qykRKRpvSsIUcsHzabuSZLCioPEURF7nKbWUVvv2DYrM/eLEVhWN5QVguHtsCgfdM9WSta8zEpsYxKxXmben6e6WWm+v3LcswbFuG/nuWITLL0PeNDaN9EdpIAl11m0LC5Wg/heiYlrtgp4EwMCc4h6hcp1a53X9vbq4u766/DUajQT/jXT35m7GogiKVSjv4uaKacJwss9ITHBGgxTonUapb0ypNAQfrBWE43kVbJe0zYESQFF7FCk17WJ59XclkxHEkOVXyOYnjDBkYFsZF95kmWU4qhEKt3+34falqxelSYUcNIjQva6ZqCnJQS4TaExELfN/MOtsKvBoXs4OGmnX3xsXcD749FFwsQF4Jz8XmAOBuRiYa5s7wligP/x8o77kWQgZvQd7rgB7ZgWW7Bs57zr5wPgyBuRbabZ9vTjgIQ6u/Fzvi8B4PxAAaQXbrB+JGEN7bsymn6VXZRwLhEkeHxYE2p9XAKUj7Szh6WyR+L9y0gS84LQxc24co9KBrwp4NLGhobc+XTQIrTj6WE+4FRG0QQAua5NxB2vr9QmPTe8FjYewqjKWIO9c+oMJxWjYkifbC3148AQytsPRj8o/wlQdNCHbq9QBs6n7jggrMl2EeOATJqL9zNQ+TRxbxki9RPPUwr1wi4duQCNHcfnUrT4jt99/cwW8=&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>Flat FSM example with three states</em>
* </center>
* 
*
* To start the implementation, let's define the necessary global variables...
*
*  @code{.c}
*  qTask_t LED_Task; /*The task node*/
*  qSM_t LED_FSM; /*The state -machine handle*/
*  qSM_State_t State_LEDOff, State_LEDOn, State_LEDBlink;
*  @endcode 
*
* Then, we define our states as the flow-diagram showed in the figure above.
*
*  @code{.c}
*  qSM_Status_t State_LEDOff_Callback( qSM_Handler_t h ) {
*      switch ( h->Signal ) {
*          case QSM_SIGNAL_ENTRY:
*              BSP_LED_OFF();
*              break;
*          case QSM_SIGNAL_EXIT: case QSM_SIGNAL_START: /*Ignore*/
*              break;
*          default:
*              if ( BUTTON_PRESSED ) {
*                  h->NextState = &State_LEDOn;
*              }
*              break;
*      }
*      return qSM_STATUS_EXIT_SUCCESS;
*  }
*  /*---------------------------------------------------------------------*/
*  qSM_Status_t State_LEDOn_Callback( qSM_Handler_t h ) {
*      static qSTimer_t timeout;
*      switch ( h->Signal ) {
*          case QSM_SIGNAL_ENTRY:
*              qSTimer_Set( &timeout, 10.0f ); /*STimer gets armed*/
*              BSP_LED_ON();
*              break;
*          case QSM_SIGNAL_EXIT: case QSM_SIGNAL_START: /*Ignore*/
*              break;
*          default:
*              if ( qSTimer_Expired( &timeout) ) { /*check if the timeout expired*/
*                  h->NextState = &State_LEDOff;
*              }
*              if ( BUTTON_PRESSED ) {
*                  h->NextState = &State_LEDBlink;
*              }
*              break;
*      }
*      return qSM_STATUS_EXIT_SUCCESS;
*  }
*  /*---------------------------------------------------------------------*/
*  qSM_Status_t State_LEDBlink_Callback( qSM_Handler_t h ) {
*      static qSTimer_t timeout; 
*      static qSTimer_t blinktime;
*      
*      switch ( h->Signal ) {
*          case QSM_SIGNAL_ENTRY:
*              qSTimer_Set( &timeout, 10.0f );
*              break;
*          case QSM_SIGNAL_EXIT: case QSM_SIGNAL_START: /*Ignore*/
*              break;
*          default:
*              if ( qSTimer_Expired( &timeout ) || BUTTON_PRESSED ) {
*                  h->NextState = &State_LEDOff;
*              }
*              if ( qSTimer_FreeRun( &blinktime, 0.5f ) ) {
*                 BSP_LED_TOGGLE();
*              }
*              break;
*      }
*      return qSM_STATUS_EXIT_SUCCESS;
*  }
*  @endcode 
*
* Finally, we add the task to the scheduling scheme running the dedicated state 
* machine. Remember that you must set up the scheduler before adding a task to
* the scheduling scheme.
*
*  @code{.c}
*  qStateMachine_Setup( &LED_FSM , NULL , &State_LEDOff , NULL , NULL );
*  qStateMachine_StateSubscribe( &LED_FSM , &State_LEDOff , NULL ,
*                                State_LEDOff_Callback , NULL , NULL );
*  qStateMachine_StateSubscribe( &LED_FSM , &State_LEDOn , NULL ,
*                                State_LEDOn_Callback , NULL , NULL );
*  qStateMachine_StateSubscribe( &LED_FSM , &State_LEDBlink , NULL ,
*                                State_LEDBlink_Callback , NULL , NULL );
*  qOS_Add_StateMachineTask( &LED_Task , &LED_FSM , qHigh_Priority , 0.1f, qEnabled , NULL );
*  @endcode 
*
* @section q_fsmsendsignals Sending signals
* To communicate within and between state-machines or even other contexts, use 
* signals. A signal is a simple value who can be used to abstract an incoming 
* event. In the receiving state-machine, a queue or a exclusion variable 
* receives the signal and holds it until the state-machine can evaluate it.
*
* When coding state-machines, the application writer can benefit from this 
* simple event-abstraction mechanism. On the one hand, there would be a more 
* uniform programming when writing states callbacks and on the other hand, the 
* communication of the state machine from other contexts becomes easier.
*
* To send a signal to a state machine, use the qStateMachine_SendSignal() API.
* This API can manage their delivery to one of these possible destinations: 
* an <em>exclusion variable</em> or a <em>signal queue</em>:
* - An <em>exclusion variable</em> its a variable with an important distinction,
* it can only be written if it is empty. The empty situation only happens, if 
* the engine has already propagated the signal within the state machine. If the 
* signal has not yet propagated, the signal sending cannot be carried out.
* - When a <em>signal queue</em> is used, the signal is put into a FIFO structure
* and the engine takes care of dispatching the signal in an orderly manner. The 
* only situation where the signal cannot be delivered is if the queue is full. 
* This its the preferred destination, as long as there is a previously 
* installed signal queue.
*
* @note If the signal-queue its available, the qStateMachine_SendSignal() will
* always select it as destination.
* @warning If a state-machine, a task, or another context sends a signal to a 
* full queue, a queue-overflow occurs. The result of the queue overflow it that
* the state-machine drops the new signal.
* 
* @section q_fsminstallsignalqueue Installing a signal queue
* A state machine can have a FIFO queue to allow the delivery of signals from 
* another contexts. If the signal queue its installed, the state-machine engine 
* constantly monitors the queue for available signals. The engine then 
* propagates the signal through the hierarchy until it is processed. To enable 
* this functionality in your state machine, the queue must be installed by using
* the qStateMachine_InstallSignalQueue() API.
*
* The install operation should be performed after both, the queue and the FSM
* are correctly initialized by using qQueue_Setup() and qStateMachine_Setup() 
* respectively.
*
* @note  Make sure that queues are enabled in the @c qconfig.h header file
* @attention When configuring a signal queue with qQueue_Setup(), remember to size
* it based on the type @ref qSM_Signal_t.
* @note If the state-machines its delegated to a task, make sure to install the 
* queue prior to setting up the task. In this way, a kernel connection can be 
* performed between the FSM signal-queue and the FSM-task, allowing the OS to 
* catch signals to produce a task event, this prevents the wait of the task for 
* the specified period, resulting in a faster handling of incoming signals.
*
* @section q_fsm_ttable Using a transition table
* In this approach, the FSM is coded in tables with the outgoing transitions of 
* every state, where each entry relates signals, actions and the target state. 
* This is an elegant method to translate the FSM to actual implementation as the 
* handling for every state and event combination is encapsulated in the table.
*
* Here, the application writer get a quick picture of the FSM and the embedded 
* software maintenance is also much more under control. A transition table 
* should be  explicitly installed in the target state with the corresponding 
* entries, an n-sized array of qSM_Transition_t elements following the layout
* described below:
*
* The API qStateMachine_Set_StateTransitions(), should be used to perform the 
* transition table installation to a specific state.
*
* <center>
* <table>
* <caption id="multi_row">Transition table layout for a state</caption>
* <tr><th>Signal Id <th>Signal action/guard <th>Target state  <th>History mode  <th>Signal data
* <tr><td> @c Signal1 <td>@c NULL <td>@c StateB <td>@c 0 <td>@c NULL
* <tr><td> @c Signal3 <td>@c DoOnSignal3 <td>@c StateD <td>@c 0 <td>@c &sig3data
* <tr><td> ... <td>... <td> ... <td> ... <td> ...
* <tr><td> @c Signal6 <td>@c NULL <td>@c StateA <td>@c 0 <td>@c NULL
* </table>
* </center>
*
* <b> Caveats: </b>
*
* - State transitions are not limited to the specification of the transition 
* table. A state callback owns the higher precedence to change a state. The 
* application writer can use both, a transition table and direct @c NextState 
* field manipulation in state callbacks to perform a transition to the FSM.
* - Special care is required when the table grows very large, that is, when 
* there are many invalid state/event combinations, leading to a waste of memory. 
* There is also a memory penalty as the number of states and events grow. The 
* application writer need to accurately account for this during initial design. 
* A statechart pattern can be used to improve the design and reduce the number 
* of transition entries.
* - The user is responsible for defining the transitions according to the 
* topology of the state machine. Undefined behaviors can occur if the topology 
* is broken with poorly defined transitions.
*
* @subsection q_fsm_sigactions Signal actions and guards
* Transition tables allow the usage of this feature. When an event-signal is 
* received from the queue, the signal-action, if available, is evaluated before 
* the transition is triggered. This action is user-defined and should be coded 
* as a function that takes a qSM_Handler_t object and returns a value of type 
* @ref qBool_t.
*
*  @code{.c}
*  qBool_t Signal_Action( qSM_Handler_t h ) {
*      /* TODO : Event -signal action*/
*      return qTrue; /*allow the state transition*/
*  }
*  @endcode 
*
* The return value is checked after to allow or reject the state transition. The
* application writer can code a boolean expression to implement 
* <em>statechart guards</em> or perform some pre-transition procedure.
* 
* @remark If a signal-action returns \ref qFalse, the event-signal is rejected, 
* preventing the state transition to be performed in the calling FSM.
* @note When a transition entry is defined. the signal-action should be located
* as the third parameter of the entry. Please see the transition layout. A
* @c NULL value will act as a NOT-defined, always allowing the state-transition.
*
* @subsection q_fsm_timeout FSM Timeout specification
* A timeout specification is mechanism to simplify the notion of time passage
* inside states. The basic usage model of the timeout signals is as follows:
*
* A timeout specification allocates one or more timer objects. The user relates
* in a table each specific timeout operations within the state where are they 
* going to operate. So, according to the table, when a state needs to arrange 
* for a timeout, the engine can set or reset the given timer. When the FSM 
* engine detects that the appropriate moment has arrived (a timer expiration 
* occurs), it inserts the timeout signal directly into the recipient's event 
* queue. The recipient then processes the timeout signal just like any other 
* signal.
*
* Given the above explanation, it is evident that for its operation, the state 
* machine requires an installed signal queue.
* A timeout specification is referenced by an object of type qSM_TimeoutSpec_t 
* and must be installed inside the state machine using the API 
* qStateMachine_InstallTimeoutSpec(). Then, timeout operations can be defined 
* in a table for each state by using the qStateMachine_Set_StateTimeouts().
*
* A timeout specification element is defined as an structure of type 
* qSM_TimeoutStateDefinition_t and should follow this layout:
*
* <center>
* <table>
* <caption id="multi_row">Timeout specification layout</caption>
* <tr><th>Timeout value  <th>Options
* </table>
* </center>
*
* The options for every timeout its a bitwise value that indicates which timeout
* should be used and the operations than should be performed internally by the 
* state-machine engine. This options can be combined with a bitwise OR and are 
* detailed as follows:
*
* - #QSM_TSOPT_INDEX(index) : To select the timeout to be used in the 
* specification. Should be a value between @c 0 and @c Q_FSM_MAX_TIMEOUTS-1 
* - #QSM_TSOPT_SET_ENTRY : To set the timeout when the specified state its 
* entering.
* - #QSM_TSOPT_RST_ENTRY : To reset the timeout when the specified state its 
* entering.
* - #QSM_TSOPT_SET_EXIT : To set the timeout when the specified state its exiting.
* - #QSM_TSOPT_RST_EXIT : To reset the timeout when the specified state its 
* exiting.
* - #QSM_TSOPT_KEEP_IF_SET : To apply the Set operation only if the timeout its 
* in a reset state.
* - #QSM_TSOPT_PERIODIC : To put the timeout in periodic mode.
* 
* @note Data associated to timeout signals should be set to @c NULL. Any other
* value will be ignored and will be passed as @c NULL to the FSM handler.
* @attention The user is responsible for writing timeout specifications 
* correctly. Care must be taken that the specifications do not collide between 
* hierarchical states to avoid overwriting operations.
* @note You can increase the number of available timeouts instances by changing 
* the @c Q_FSM_MAX_TIMEOUTS configuration macro inside @c qconfig.h.
* 
* @subsection q_fsm_example2 Demonstrative example using transition tables 
* The following example shows the implementation of the led-button FSM presented
* above by using the transition table approach with signal-queue and a timeout 
* specification.
* 
* Before getting started, the required variables should be defined:
*
*  @code{.c}
*  /*define the FSM application event-signals*/
*  #define SIGNAL_BUTTON_PRESSED   ( (qSM_SigId_t)1 )
*  #define SIGNAL_TIMEOUT          ( QSM_SIGNAL_TIMEOUT( 0 ) )
*  #define SIGNAL_BLINK            ( QSM_SIGNAL_TIMEOUT( 1 ) )
*  
*  qTask_t LED_Task; /*The task node*/
*  qSM_t LED_FSM; /*The state-machine handler*/
*  qSM_State_t State_LEDOff, State_LEDOn, State_LEDBlink;
*  qQueue_t LEDsigqueue; /*the signal-queue*/ 
*  qSM_Signal_t led_sig_stack[ 5 ];  /*the signal-queue storage area*/
*  qSM_TimeoutSpec_t tm_spectimeout;
*  
*  /*create the transition tables for every state*/
*  qSM_Transition_t LEDOff_transitions[] = {
*      { SIGNAL_BUTTON_PRESSED, NULL, &State_LEDOn    , 0, NULL}
*  };
*  
*  qSM_Transition_t LEDOn_transitions[] = {
*      { SIGNAL_TIMEOUT,        NULL, &State_LEDOff   , 0, NULL},
*      { SIGNAL_BUTTON_PRESSED, NULL, &State_LEDBlink , 0, NULL}
*  };
*  
*  qSM_Transition_t LEDBlink_transitions[] = {
*      { SIGNAL_TIMEOUT,        NULL, &State_LEDOff   , 0, NULL},
*      { SIGNAL_BUTTON_PRESSED, NULL, &State_LEDOff   , 0, NULL}
*  };
*  
*  /*define the timeout specifications */
*  qSM_TimeoutStateDefinition_t LedOn_Timeouts[] = {
*      { 10.0f,  QSM_TSOPT_INDEX( 0 ) | QSM_TSOPT_SET_ENTRY | QSM_TSOPT_RST_EXIT  },
*  };
*  
*  qSM_TimeoutStateDefinition_t LEDBlink_timeouts[] = {
*      { 10.0f,  QSM_TSOPT_INDEX( 0 ) | QSM_TSOPT_SET_ENTRY | QSM_TSOPT_RST_EXIT  },
*      { 0.5f,   QSM_TSOPT_INDEX( 1 ) | QSM_TSOPT_SET_ENTRY | QSM_TSOPT_RST_EXIT | QSM_TSOPT_PERIODIC  }
*  };
*  @endcode 
*
* Then, we define the callback for the states.
* 
*  @code{.c}
*  qSM_Status_t State_LEDOff_Callback( qSM_Handler_t h ) {
*      switch ( h->Signal ) {
*          case QSM_SIGNAL_ENTRY:
*              BSP_LED_OFF();
*              break;
*          default:
*              break;
*      }
*      return qSM_STATUS_EXIT_SUCCESS;
*  }
*  /*---------------------------------------------------------------------*/
*  qSM_Status_t State_LEDOn_Callback( qSM_Handler_t h ) {
*      switch ( h->Signal ) {
*          case QSM_SIGNAL_ENTRY:
*              BSP_LED_ON();
*              break;
*          default:
*              break;
*      }
*      return qSM_STATUS_EXIT_SUCCESS;
*  }
*  /*---------------------------------------------------------------------*/
*  qSM_Status_t State_LEDBlink_Callback( qSM_Handler_t h ) {
*      switch ( h->Signal ) {
*          case SIGNAL_BLINK:
*              BSP_LED_TOGGLE();
*              break;
*          default:
*              break;
*      }
*      return qSM_STATUS_EXIT_SUCCESS;
*  }
*  @endcode 
* 
* In the previous code snippet, we assumed that @c SIGNAL_BUTTON_PRESSED can be
* delivered from either the interrupt context or another task.
*
* To finish the setup, a task is added to handle the FSM and then, the 
* transition table can be installed with the other required objects.
*
*  @code{.c}
*  qStateMachine_Setup( &LED_FSM, NULL, &State_LEDOff, NULL, NULL );
*  qStateMachine_StateSubscribe( &LED_FSM, &State_LEDOff, QSM_STATE_TOP, State_LEDOff_Callback, NULL, NULL );
*  qStateMachine_StateSubscribe( &LED_FSM, &State_LEDOn, QSM_STATE_TOP, State_LEDOn_Callback, NULL, NULL );
*  qStateMachine_StateSubscribe( &LED_FSM, &State_LEDBlink, QSM_STATE_TOP, State_LEDBlink_Callback, NULL, NULL );
*  
*  qQueue_Setup( &LEDsigqueue, led_sig_stack, sizeof(qSM_Signal_t), qFLM_ArraySize(led_sig_stack) );
*  qStateMachine_InstallSignalQueue( &LED_FSM, &LEDsigqueue );
*  
*  qStateMachine_InstallTimeoutSpec( &LED_FSM, &tm_spectimeout );
*  qStateMachine_Set_StateTimeouts( &State_LEDOn, LedOn_Timeouts, qFLM_ArraySize(LedOn_Timeouts) );
*  qStateMachine_Set_StateTimeouts( &State_LEDBlink, LEDBlink_timeouts, qFLM_ArraySize(LEDBlink_timeouts) );
*  
*  qStateMachine_Set_StateTransitions( &State_LEDOff, LEDOff_transitions, qFLM_ArraySize(LEDOff_transitions) );
*  qStateMachine_Set_StateTransitions( &State_LEDOn, LEDOn_transitions, qFLM_ArraySize(LEDOn_transitions) );
*  qStateMachine_Set_StateTransitions( &State_LEDBlink, LEDBlink_transitions, qFLM_ArraySize(LEDBlink_transitions) );
*  
*  qOS_Add_StateMachineTask( &LED_Task, &LED_FSM, qMedium_Priority, 0.1f, qEnabled, NULL );
*  @endcode 
*
* @section qfsm_happroach Using the hierarchical approach
* In conventional state machine designs, all states are considered at the same 
* level. The design does not capture the commonality that exists among states. 
* In real life, many states handle most transitions in similar fashion and 
* differ only in a few key components. Even when the actual handling differs, 
* there is still some commonality. It is in these situations where the 
* hierarchical designs makes the most sense.
* 
* A hierarchical state-machine is characterized by having compound states. A 
* composite state is defined as state that has inner states and can be used as a
* decomposition mechanism that allows factoring of common behaviors and their 
* reuse. And this is the biggest advantage of this design, because it captures
* the commonality by organizing the states as a hierarchy. The states at the 
* higher level in hierarchy perform the common handling, while the lower level 
* states inherit the commonality from higher level ones and perform the state 
* specific functions.
* 
* @subsection q_fsm_example3 Example usign a hierarchical FSM
* This example takes the "Cruise Control" study case, a real-time system that
* manages the speed of an automobile based on inputs from the driver.
* 
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>hsm</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;zoom&quot;:1.2,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-19T16:51:35.501Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;QdIZd3r2DwtN3vC1hyVB\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;Ucjj-E1xw4AO6E8yxrXi\&quot; name=\&quot;P치gina-1\&quot;&gt;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&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>Cruise control FSM example</em>
* </center>
*
* The behavior of this system is state-dependent in that the executed actions
* correspond not only to the driver input, but also on the current state of the 
* system and with the status of the engine and the brake.
* The figure above illustrate the modeling of this system with the 
* "Automated Control" state acting as composite.
*
* Before getting started, the required user-defined signals, variables, and 
* entries of the transition table should be defined:
* 
*  @code{.c}
*  #define  SIGNAL_ENGINE_ON           ( (qSM_SigId_t)(1) )
*  #define  SIGNAL_ACCEL               ( (qSM_SigId_t)(2) )
*  #define  SIGNAL_RESUME              ( (qSM_SigId_t)(3) )
*  #define  SIGNAL_OFF                 ( (qSM_SigId_t)(4) )
*  #define  SIGNAL_BRAKE_PRESSED       ( (qSM_SigId_t)(5) )
*  #define  SIGNAL_CRUISE              ( (qSM_SigId_t)(6) )
*  #define  SIGNAL_REACHED_CRUISING    ( (qSM_SigId_t)(7) )
*  #define  SIGNAL_ENGINE_OFF          ( (qSM_SigId_t)(8) )
*  
*  qTask_t CruiseControlTask;
*  qSM_t Top_SM;
*  
*  /*highest level states*/
*  qSM_State_t state_idle, state_initial, state_cruisingoff, state_automatedcontrol;
*  /*states inside the state_automatedcontrol*/
*  qSM_State_t state_accelerating, state_cruising, state_resuming;
*  
*  qQueue_t top_sigqueue;
*  qSM_Signal_t topsm_sig_stack[ 10 ];
*  
*  /*=======================================================================*/
*  /*                             TRANSITION TABLES                         */
*  /*=======================================================================*/
*  qSM_Transition_t idle_transitions[] =
*  {
*  { SIGNAL_ENGINE_ON, SigAct_ClearDesiredSpeed, &state_initial      , 0, NULL }
*  };
*  
*  qSM_Transition_t initial_transitions[] =
*  {
*  { SIGNAL_ACCEL,     SigAct_BrakeOff,          &state_accelerating , 0, NULL }
*  };
*  
*  qSM_Transition_t accel_transitions[] =
*  {
*  { SIGNAL_CRUISE,     NULL,                    &state_cruising     , 0, NULL }
*  };
*  
*  qSM_Transition_t cruising_transitions[] =
*  {
*  { SIGNAL_OFF,       NULL,                     &state_cruisingoff  , 0, NULL },
*  { SIGNAL_ACCEL,     NULL,                     &state_accelerating , 0, NULL }
*  };
*  
*  qSM_Transition_t resuming_transitions[] =
*  {
*  { SIGNAL_ACCEL,      NULL,                    &state_accelerating , 0, NULL }
*  };
*  
*  qSM_Transition_t cruisingoff_transitions[] =
*  {
*  { SIGNAL_ACCEL,      SigAct_BrakeOff,         &state_accelerating , 0, NULL },
*  { SIGNAL_RESUME,     SigAct_BrakeOff,         &state_resuming     , 0, NULL },
*  { SIGNAL_ENGINE_OFF, NULL,                    &state_idle         , 0, NULL }
*  };
*  
*  qSM_Transition_t automated_transitions[] =
*  {
*  { SIGNAL_BRAKE_PRESSED,   NULL,               &state_cruisingoff  , 0, NULL }
*  };
*  /*---------------------------------------------------------------------*/
*  @endcode 
*
* Then, signal-actions and state callbacks are later defined
*
*  @code{.c}
*  /*=======================================================================*/
*  /*                      EVENT-SIGNAL ACTIONS AND GUARDS                  */
*  /*=======================================================================*/
*  qBool_t SigAct_ClearDesiredSpeed( qSM_Handler_t h ) {
*      (void)h;
*      Speed_ClearDesired();
*      return qTrue;
*  }
*  /*---------------------------------------------------------------------*/
*  qBool_t SigAct_BrakeOff( qSM_Handler_t h ) {
*      (void)h; /*unused*/
*      return ( BSP_BREAK_READ() == OFF ) ? qTrue : qFalse;  /*check guard*/
*  }
*  /*=======================================================================*/
*  /*                  STATE CALLBACK FOR THE TOP FSM                      */
*  /*=======================================================================*/
*  qSM_Status_t state_top_callback( qSM_Handler_t h ) {
*      qSM_Status_t RetVal = qSM_STATUS_EXIT_SUCCESS;
*      switch ( h->Signal ) {
*          case QSM_SIGNAL_ENTRY:
*              break;
*          case QSM_SIGNAL_EXIT:
*              break;
*      } 
*      return RetVal;
*  }
*  /*=======================================================================*/
*  /*                  CALLBACKS FOR THE STATES ABOVE TOP                    */
*  /*=======================================================================*/
*  qSM_Status_t state_idle_callback( qSM_Handler_t h ) {
*      /*TODO : state activities*/
*      return qSM_EXIT_SUCCESS;
*  }
*  /*---------------------------------------------------------------------*/
*  qSM_Status_t state_initial_callback( qSM_Handler_t h ) {
*      /*TODO : state activities*/
*      return qSM_EXIT_SUCCESS;
*  }
*  /*---------------------------------------------------------------------*/
*  qSM_Status_t state_cruisingoff_callback( qSM_Handler_t h ) {
*      /*TODO : state activities*/
*      return qSM_EXIT_SUCCESS;
*  }
*  /*---------------------------------------------------------------------*/
*  qSM_Status_t state_automatedcontrol_callback( qSM_Handler_t h ) {
*      /*TODO : state activities*/
*      return qSM_EXIT_SUCCESS;
*  }
*  /*=======================================================================*/
*  /*          STATE CALLBACKS FOR THE AUTOMATED CONTROL FSM                */
*  /*=======================================================================*/
*  qSM_Status_t state_accelerating_callback( qSM_Handler_t h ) {
*      switch ( h->Signal ) {
*          case QSM_SIGNAL_EXIT:
*              Speed_SelectDesired();
*              break;
*          default:
*              Speed_Increase();
*              break;
*      }
*      return qSM_EXIT_SUCCESS;
*  }
*  /*---------------------------------------------------------------------*/
*  qSM_Status_t state_resuming_callback( qSM_Handler_t h ) {
*      Cruising_Resume();
*      return qSM_EXIT_SUCCESS;
*  }
*  /*---------------------------------------------------------------------*/
*  qSM_Status_t state_cruising_callback( qSM_Handler_t h ) {
*      Speed_Maintain();
*      return qSM_EXIT_SUCCESS;
*  }
*  
*  @endcode
*
* Finally, the dedicated task for the FSM and related objects are configured.
*
*  @code{.c}
*  qStateMachine_Setup( &Top_SM, state_top_callback, &state_idle, NULL, NULL );
*  /*subscribe to the highest level states*/
*  qStateMachine_StateSubscribe( &Top_SM, &state_idle, QSM_STATE_TOP, state_idle_callback, NULL, NULL );
*  qStateMachine_StateSubscribe( &Top_SM, &state_initial, QSM_STATE_TOP, state_initial_callback, NULL, NULL );
*  qStateMachine_StateSubscribe( &Top_SM, &state_cruisingoff, QSM_STATE_TOP, state_cruisingoff_callback, NULL, NULL );
*  qStateMachine_StateSubscribe( &Top_SM, &state_automatedcontrol, QSM_STATE_TOP, state_automatedcontrol_callback, NULL, NULL );
*  /*subscribe to the states within the state_automatedcontrol*/
*  qStateMachine_StateSubscribe( &Top_SM, &state_accelerating, &state_automatedcontrol, state_accelerating_callback, NULL, NULL );
*  qStateMachine_StateSubscribe( &Top_SM, &state_resuming, &state_automatedcontrol, state_resuming_callback, NULL, NULL );
*  qStateMachine_StateSubscribe( &Top_SM, &state_cruising, &state_automatedcontrol, state_cruising_callback, NULL, NULL );
*  
*  qQueue_Setup( &top_sigqueue, topsm_sig_stack, sizeof(qSM_Signal_t), qFLM_ArraySize(topsm_sig_stack) );
*  qStateMachine_InstallSignalQueue( &Top_SM, &top_sigqueue );
*  
*  qStateMachine_Set_StateTransitions( &state_idle, idle_transitions, qFLM_ArraySize(idle_transitions) );
*  qStateMachine_Set_StateTransitions( &state_initial, initial_transitions, qFLM_ArraySize(initial_transitions) );
*  qStateMachine_Set_StateTransitions( &state_cruisingoff, cruisingoff_transitions, qFLM_ArraySize(cruisingoff_transitions) );
*  qStateMachine_Set_StateTransitions( &state_automatedcontrol, automated_transitions, qFLM_ArraySize(automated_transitions) );
*  qStateMachine_Set_StateTransitions( &state_accelerating, accel_transitions, qFLM_ArraySize(accel_transitions) );
*  qStateMachine_Set_StateTransitions( &state_resuming, resuming_transitions, qFLM_ArraySize(resuming_transitions) );
*  qStateMachine_Set_StateTransitions( &state_cruising, cruising_transitions, qFLM_ArraySize(cruising_transitions) );
*  
*  qOS_Add_StateMachineTask(  &CruiseControlTask, &Top_SM, qMedium_Priority, 0.1f, qEnabled, NULL );
*  @endcode
* 
* @subsection q_fsm_example4 Example with history pseudo-states
* State transitions defined in high-level composite states often deal with 
* events that require immediate attention; however, after handling them, the 
* system should return to the most recent substate of the given composite state.
* UML statecharts address this situation with two kinds of history pseudostates:
* @a "shallow history" and @a "deep history"( denoted as the circled @c H and 
* @c H* icon respectively in figure).
*
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>fsmhist</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;zoom&quot;:1.2,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-19T18:43:21.516Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;Ch7yXC-GbSBqROWlSNdq\&quot; version=\&quot;20.4.1\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;sgRdDsJHhmN2pV4VL9Bt\&quot; name=\&quot;P치gina-1\&quot;&gt;7Vtbb+o4EP41vKzUKLbjXB4bWrYr7UpH6sOe87TKIS5YJ8QoMS3tr18bbHKxUQM9AUoDEoonyRjP92VmPHZGaLxY/1kky/k/LCXZCLrpeoTuRhBi6ItfKXjdCm5QEG4ls4KmWxmoBI/0jSihq6QrmpKycSFnLON02RROWZ6TKW/IkqJgL83LnljW7HWZzIgheJwmmSn9l6Z8rqTAj6oTD4TO5qrrEAbbE4tEX6xGUs6TlL3UROh+hMYFY3x7tFiPSSaNp+2yvW+y5+zujxUk511u8P5b+GGcv/21uP1RrPO3+/U4vlFanpNspQas/ix/1RYo2CpPiVTijlD8MqecPC6TqTz7IjAXsjlfZKIFxGHJC/aLjFnGis3dKHTlV5x5olmm5TnLiRSxnE+SBc0kOf5eTWmaiK7HLC+Z7Fwp02YXBouTjM5ycZyRJ64UKMoAV7VtfatBkoKT9V7rgR0mgsyELQgvXsUl6gYUKRgVkQF0PQcqLr/UmKHhntdIAYDneJ4ipSLkbNdFhZk4ULAdACG0QOhn0jw/xcFMHjzyhBOsxaKX3ZlToC3k9778tiF/INkz4XSaWLHuEUwPBC0wgRVMLzSx1Pj+dhxRRxz9Acf9OAb+eUH0Bn96LHRRN+hAX9Dh96EjeXorcwrRmmZJWdJpE60mtLuA73bA5h3Tx5uvjRCuG0wmEyu6JU8Krv+w4shGNqHSNJv/JYakWnIAZE35d3nGiVyk2j9E+8Z1XAHYVnC31vfKxmut8Y0UVIBBCiXbGpCkRor1LktqJMCWgKplBckSTp+b6m3MUD18Y1R0XJHQEwMF7u4DWpT0oBOhaPcJm/pLtiqmRKmsJ16WXoJaLzonNpyWViwgmhFuKBZIJq+1y5bygtLg/c6Kxz8K/uDFjvViqHMi0ZsjC0z0cDwZ4TsDRDFw3kSqZUppHBHXs1slXtA03YBQkJK+JT83iqQtFReFVhzLnoSmFWelQsGggIbajr4CL+zoNvvC1sNtdxBZsbX4p97yi/C6gxQTA2sFKWAGqVxY8nu98WMTsrBuVgFq09IR6uKjUdQmHEROFB0ZdPwOys4eaCILnW1zHm+Y8+wtRICweyGiN7+kg9m7SKIByR2S7gVWIcBQETwavgvI/YCtGnhFCUKnWeylB3qEjdgcOQE8LtCjCDhu7QPbpGxR7ewxH9gKnVdE0S+dwyLQKm6AMDye2m1lECAnAJfGZ1vN15b6wCH1qWJnO4nF0AicMDhpBmvWfx9Mv5RldFmSPoCx2/9R9Q36xQNDIxVFju+ZkNgWN6O+EDHLkA9/fGFIPMsjclI8LIXFYWrQzb0FHd0bwL4RLn8fgLbqoS1SgSFSaSj9NpTQtVeBTzpJt9XNhiexE3ywM3xR1OOmHVu97IomQd1Wm690EmSSDoOjJ0HYa+cBGDog2rsqffb5EOxQQfzM1P7S83sfeo29DKiV58i1iCNXrN5RXY+7l8P1odx6PNf1ZiO5uQh7o2q3kev4eHRte42wTCfcoPLbLXqHwPGA3y7jHhwtdHmsrlcvVFzOY2MpAeP4ftiicug8028nGsA9+xYV2GEP7OATP2v8N/ZIQviB1DZsK0OXndpa9gjj+HbwW4fWNoP2Aqj9ZZrT+i3LrlccxwO4HwZ3z76Ik4Jr3RQ7HsD9MLg4dPCZsT1sU6yy6SfJNqr0aH/BYZdGDJOwj03CEIC9TMKk3subhFkWEXB8N7jEg12i8SYb6Mshimb1wviWCNVr9+j+fw==&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>Example with history pseudo-states</em>
* </center>
* 
* - @a Shallow @a history :  A transition to the shallow history state in a 
* composite state invokes the last state that was active, at the same depth as 
* the history state itself, prior to the most recent exit of the composite state.
* - @a Deep @a history :  A transition to the deep history state within a 
* composite state invokes the state that was active, immediately before the most
* recent exit of the composite state. The last active state can be nested at any
* depth.
* 
* Here, the way to specify this type of transitions in QuarkTS is very 
* straightforward, you only need to assign the history-mode in the last entry 
* of the transition as shown below:
*
*  @code{.c}
*  #define SIGNAL_A ( (qSM_SigId_t)(1) )
*  #define SIGNAL_B ( (qSM_SigId_t)(2) )
*  #define SIGNAL_C ( (qSM_SigId_t)(3) )
*  #define SIGNAL_D ( (qSM_SigId_t)(4) )
*  #define SIGNAL_E ( (qSM_SigId_t)(5) )
*  #define SIGNAL_F ( (qSM_SigId_t)(6) )
*
*  qQueue_t sigqueue;
*  qSM_Signal_t topsm_sig_stack[ 10 ];
*  qSM_t super;
*  qSM_State_t state1 , state2 , state3 , state4 , state5 , state6;
*
*  qSM_Transition_t state1_transitions [] = {
*      { SIGNAL_A , NULL , &state2 , qSM_TRANSITION_SHALLOW_HISTORY, NULL },
*      { SIGNAL_B , NULL , &state2 , qSM_TRANSITION_DEEP_HISTORY, NULL },
*      { SIGNAL_C , NULL , &state2 , qSM_TRANSITION_NO_HISTORY, NULL }
*  };
*
*  qSM_Transition_t state2_transitions [] = {
*      { SIGNAL_D , NULL , &state1 , 0, NULL }
*  };
*
*  qSM_Transition_t state3_transitions [] = {
*      { SIGNAL_E , NULL , &state4 , 0, NULL }
*  };
*
*  qSM_Transition_t state5_transitions [] = {
*      { SIGNAL_F , NULL , &state6 , 0, NULL }
*  };
*  @endcode
*
* Next, the configuration and topology of the state-machine is presented,
* including the default transitions (the small circles filled with black).
* Please do not forget to define the callbacks for each state.
*
*  @code{.c}
*  qStateMachine_Setup( &super , state_top_callback , &state1 , NULL , NULL );
*  qStateMachine_StateSubscribe( &super , &state1 , QSM_STATE_TOP , state1_callback , NULL , NULL );
*  qStateMachine_StateSubscribe( &super , &state2 , QSM_STATE_TOP , state2_callback , &state3 , NULL );
*  qStateMachine_StateSubscribe( &super , &state3 , &state2 , state3_callback , NULL , NULL );
*  qStateMachine_StateSubscribe( &super , &state4 , &state2 , state4_callback , &state5 , NULL );
*  qStateMachine_StateSubscribe( &super , &state5 , &state4 , state5_callback , NULL , NULL );
*  qStateMachine_StateSubscribe( &super , &state6 , &state4 , state6_callback , NULL , NULL );
*
*  qQueue_Setup( &sigqueue , topsm_sig_stack , sizeof(qSM_Signal_t), qFLM_ArraySize(topsm_sig_stack ) );
*  qStateMachine_InstallSignalQueue( &super , &sigqueue );
*  qStateMachine_Set_StateTransitions( &state1 , state1_transitions , qFLM_ArraySize( state1_transitions ) );
*  qStateMachine_Set_StateTransitions( &state2 , state2_transitions , qFLM_ArraySize( state2_transitions ) );
*  qStateMachine_Set_StateTransitions( &state3 , state3_transitions , qFLM_ArraySize( state3_transitions ) );
*  qStateMachine_Set_StateTransitions( &state5 , state5_transitions , qFLM_ArraySize( state5_transitions ) );
*  qOS_Add_StateMachineTask( &SMTask , &super , qMedium_Priority , 0.1f, qEnabled , NULL );
*  @endcode 
* 
*/