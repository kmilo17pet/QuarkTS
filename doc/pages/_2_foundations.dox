/*! @page q_foundations Fundamentals
* @tableofcontents
*
* @section rtcmodel RTC(Run To Completion) model
* In this pattern each task runs until it finishes or explicitly yields control 
* back to the scheduler. Events are serviced by the kernel in the scheduler 
* loop. If an event is available, it is posted to the task based on 
* the scheduling @ref q_osrules "rules", and then the dispatcher triggers the 
* task. The task executes the actions associated with that event and then 
* returns back to the scheduler.
* 
* This pattern means that in the absence of exceptions or asynchronous 
* destruction of the task execution, a pending event occurrence is dispatched 
* only after the processing of the previous occurrence is completed, and a 
* stable task-scheme configuration has been reached. That is, an event 
* occurrence will never be dispatched while the task execution is busy 
* processing the previous one. This behavioral paradigm was chosen to avoid 
* complications arising from concurrency conflicts that may occur when a task 
* tries to respond to multiple concurrent or overlapping events. This also 
* provides better power efficiency. In the absence of events, the developer 
* can use CPU low-power modes and make the core active only during the 
* execution of an RTC step.
*
* The provided features enables you to implement task procedures that does not 
* have to execute all the way down to the last line of code. Instead execution 
* can be break down into different entities by using @ref q_fsm or by using 
* @ref q_qcoroutines where the procedure execution can be suspended and resumed
* at defined locations.
*
* @section q_timmingapproach Timing Approach
* The kernel implements a <a style="font-weight:bold" href="https://en.wikipedia.org/wiki/Time-triggered_architecture">Time-Triggered Architecture (TTA)</a>
* , in which the tasks are triggered by comparing the corresponding task-time 
* with a reference clock. The reference clock must be real-time and follow a
* monotonic behavior. Usually, all embedded systems can provide this kind of 
* reference with a constant tick generated by a periodic background 
* hardware-timer, typically, at @c 1Khz or @c 1mS tick.
*
* For this, the kernel allows you to select the reference clock source among 
* these two scenarios:
*
* - <b>When tick already provided</b>: The reference is supplied by the Hardware 
* Abstraction Layer (HAL) of the device. It is the simplest scenario and it 
* occurs when the framework or SDK of the embedded system includes a HAL-API 
* that obtains the time elapsed since the system starts, usually in milliseconds
* and taking a 32-bit counter variable.
* - <b>When the tick is not provided</b>: The application writer should use bare-metal 
* code to configure the device and feed the reference clock manually. Here, a 
* hardware timer should raise an interrupt periodically. After the <em>Interrupt 
* Service Routine(ISR)</em> has been implemented using the platform-dependent code, 
* the qClock_SysTick() API must be called inside. It is recommended that the 
* reserved ISR should only be used by QuarkTS.
* 
* The qOS_Setup() function should be the first call to the OS APIs. qOS_Setup() 
* prepares the kernel instance, sets the reference clock, defines the Idle-Task 
* callback and allocates the stack for the internal queue.
*
* To establish the reference clock source, the qOS_Setup() function is used. In 
* fact, this function should be the first call to the operating system API, as 
* it also prepares the kernel, defines the @ref q_idletask "Idle task", and 
* reserves the required stack for the internal queue.
*
* @note A call to qOS_Setup() is mandatory and must be called once in the 
* application mainthread before any kind of interaction with the OS.
*
* Usage example:
* - Scenario 1 : When tick is already provided
*  @code{.c}
*  #include "QuarkTS.h"
*  #include "HAL.h"
*
*  #define TIMER_TICK 0.001 /* 1ms */
*
*  void main( void ) {
*      HAL_Init();
*      qOS_Setup( HAL_GetTick , TIMER_TICK , IdleTask_Callback );
*      // TODO: add Tasks to the scheduler scheme and run the OS
*  }
*  @endcode
*
* - Scenario 2 : When the tick is not provided
*  @code{.c}
*  #include "QuarkTS.h"
*  #include "DeviceHeader.h"
*
*  #define TIMER_TICK       ( 0.001f ) /* 1ms */
*
*  void Interrupt_Timer0( void ) {
*      qClock_SysTick();
*  }
* 
*  void main( void ) {
       MCU_Init();
*      HAL_Init();
*      qOS_Setup( NULL , TIMER_TICK , IdleTask_Callback );
*      // TODO: add Tasks to the scheduler scheme and run the OS
*  }
*  @endcode
*
* @section q_tasks Tasks
* Like many operating systems, the basic unit of work is the task. Tasks can 
* perform certain functions, which could require periodic or one-time execution,
* update of specific variables or waiting for specific events. Tasks also could
* be controlling specific hardware or be triggered by hardware interrupts. In 
* the QuarkTS OS, a task is seen as a node concept that links together:
*
* - Program code performing specific task activities (callback function)
* - Execution interval (time)
* - Number of execution (iterations)
* - Event-based data
*
* The OS uses a <b>Task Control Block (TCB)</b> to represent each task, storing 
* essential information about task management and execution. Part of this 
* information also includes link-pointers that allows it to be part of one of 
* the lists available in the <b>Kernel Control Block (KCB)</b>.
* 
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>tasknode</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-18T13:11:02.654Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;QycpXy9CV1RyLdRAMmhi\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;Wp6tzC3tOU-Ykbh8yUCR\&quot; name=\&quot;Página-1\&quot;&gt;7VtRb5s6FP41eZm0CHBoyGOTNrfSuulqne62Rw/c4NXBEThNcn/9tcEOYENC2gTQbtpKxQfbsc/3HfvwmQzAbLn9K4ar8DMNEBk4VrAdgLuB49jAdvk/YdlJi+14mWUR40DacsMT/hdJoyWtaxygpFSRUUoYXpWNPo0i5LOSDcYx3ZSrPVNS/tQVXCDD8ORDYlq/44CFaho3k/zGA8KLUH6054yzG0uoKsuZJCEM6KZgAvcDMIspZdnVcjtDRHhP+SVrN6+5ux9YjCLWpMEo+riZh8t/vpCnr3SC0G/iPXyUvbxCspYTloNlO+WBmK6jAIlOrAGYbkLM0NMK+uLuhoPObSFbEl6y+eUzJmRGCY3TtsCyxvP5XNhpxAr27IfbExbTF1TZgvf0JEcRQuaHspc5XGIi2PSAyCti2If7bhRA3LVTOS8UM7StdZi9h4ETGNElYvGOV1ENJhI5xV0HZOVNkQiyTljggEIcSu4t9l3n8PALidAJaDkGWhGPOG4hOHpJ3ofcYSSUPaIRMuH0LPEr7Qo0u3vARl0DBgzA+MpCfkH/5QqWDtZN12CNDLBwxFDMy1ewdLC8rsFyTbA4VpBhGl0XQh0ux+oarhsDLspCFItsDiYvIkGEDA6Hwyt0OnSdJx3ja4pYixYAx1NEr02wvDODdXJEdej7imyvyve2dSnnT66RUouW17NAUUtoARsU8Cd/WaQxC+mCRpDc59ZpGb28ziOlK4nZb8TYTsoYcM1oGVG0xexH4fqn7Epc322LhZ0qRHy2P4qFn8VC3igtqVYHmFCHur+OX9Op2QcoIFx0mADco3Qd++iQ65WOA+MFYgcqOtWMihHhed5reSDnJ8i5pZEeL6V6cHa+ktqm0mGGaxTcCoGPl3wCkwT7ZX+XwblGXq4fHQ08r5otBTq4FXRQtsbxKT/hb8qfswv7+kjLgMeg3EU2TdmqKHjqHdk1tFYdZX4wOkoZu5/2O0hsqj/vJbGipF2i5NBxj7BSsd8qsl82qw2A7qjcFfVqNalTqWffHOno0tQztazLUK/Hq+HRVQ50usrpTy9vpRrQqea2TDVTiXtfnlSRDb2BRm3kSeOun2FMVW37iBPWsv/7J6JpOLld49RAQjtPItA0D2ieBfc6n500XOmzQOlqqXfGZTpO3rrSO+V+GqaznFZwV6i2EhWSE5IgmcfWDcuxKlfFPGCyAZx302mgc176+bDXkdFtGq0R3gZnSqMbZtGnMt6ZVAZoLeFHHRC+gbZcILzctw/sH8EcixH8idwfd8n9kZZ7OP2mPjiR+l7lqC5KfbXrXdf6Pqp1Iy0p2b8ZcirhR67WUctqndNA738bzawz0Gz/8qjVwVFNZxqJllkCnRKNudUxtZxWqDU8LOfWnGccF4+1Y+jARV4w6iVbpR5y9Hlw8iey+lIpgntoyz8aalYbGYJ50LL9lr5WpgUZQ1tmEFeduJqyFyR4EfEiQc+imZCk+N5ObqV5iYMgfS0gWUEfR4vHtNrdKLd8leQRJsqbP5M0KkLeEPEeptL1fGzulP9x181EFLt8rDNetvMy/xPVYzajER8+xGlsIJiwDUpYuj4wyOCvdKZWMQSV+lan0lUmL+XV5iIanaMnDiosjqh0Sjc//8v15pnJh0+z6QDccuMnFEeIDGbO4JZ/vsVR4D4RXU4JFS9z85VHHDeC6YdvqknGQLPqlZN31gFOlqnXrm6sP94AUzjeq13tcPL/e7hS4ftWRXvHPFwRq8E1fPu7pdiWvqVcakfhxfyLe1kak3//Edz/Bw==&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>Task node illustration</em>
* </center>
*
* Each task performs its activities via a @a callback function and each of them is
* responsible for supporting cooperative multitasking by being “good neighbors”,
* i.e., running their callback methods quickly in a non-blocking way and 
* releasing control back to the scheduler as soon as possible (returning).
*
* Every task node, must be defined using the qTask_t data-type and the callback
* is defined as a function that returns void and takes a qEvent_t data structure
* as its only parameter (This input argument can be used later to get event 
* information, see @ref eventdata).
*
*  @code{.c}
*  qTask_t UserTask;
*  void UserTask_Callback( qEvent_t eventdata ) {
*      // TODO : Task code
*  }
*  @endcode
*
* @note All tasks in QuarkTS must ensure their completion to return the CPU
* control back to the scheduler to follow the @ref rtcmodel, otherwise, the 
* scheduler will hold the execution state for that task, preventing the 
* activation of other tasks.
*
* @subsection q_idletask The idle task
* Its a special task loaded by the OS scheduler when there is nothing else to 
* do (no task in the whole scheme has reached the ready state). The idle task is
* already hard-coded into the kernel, ensuring that at least, one task is able 
* to run. Additionally, the OS setup this task with the lowest possible priority
* to ensure that does not use any CPU time if there are higher priority 
* application tasks able to run. The idle task doesn't perform any active 
* functions, but the user can decide if it should perform some activities 
* defining a callback function for it. This could be done at the beginning of 
* the kernel setup. Of course, the callback must follow the same function 
* prototype for tasks.
* @note To disable the idle-task activities, a @c NULL should be passed as 
* argument on qOS_Setup() or qOS_Set_IdleTask().
*
* @subsection q_addtasks Adding tasks to the scheme
* After setting up the kernel with qOS_Setup(), the user can proceed to deploy 
* the multitasking application by adding tasks. If the task node and their 
* respective callback is already defined, the task can be added to the scheme 
* using qOS_Add_Task(). This API can schedule a task to run every @c t seconds,
* @c n executions times and invoking the @c callbackFcn method on every pass.
*
* <b> Caveats: </b>
*
* -# A task with time argument @c t defined as @c qTimeImmediate, will always 
* get the @c qReady state in every scheduling cycle, as consequence, the idle 
* task will never gets dispatched.
* -# Tasks do not remember the number of iteration set initially by the 
* @c n executions argument. After the iterations are done, the internal iteration
* counter decreases until reach the zero. If another set of iterations is 
* needed, the user should set the number of iterations again and resume the 
* task explicitly.
* -# Tasks that performed all their iterations, put their own state to @c 
* qDisabled. Asynchronous triggers do not affect the iteration counter.
* -# The @c arg parameter can be used as storage pointer, so, for multiple data, 
* create a structure with the required members and pass a pointer to that
* structure.
*
* Invoking qOS_Add_Task() is the most generic way to adding tasks to the scheme, 
* supporting a mixture of time-triggered and event-triggered tasks, however, 
* additional simplified API functions are also provided to add specific purpose
* tasks:
*
* - Event-triggered only tasks → qOS_Add_EventTask().
* - State-machine tasks → qOS_Add_StateMachineTask().
* - AT Command Line Interface tasks → qOS_Add_ATCLITask().
*
* @subsection q_eventtasks Event-triggered tasks
* An event-triggered task reacts asynchronously to the occurrence of events in 
* the system, such as external interrupts or changes in the available resources.
*
* The API qOS_Add_EventTask() is intended to add this kind of tasks, keeping it
* in a @c qSuspended state. Only asynchronous events followed by their priority
* value dictates when a task can change to the @c qRunning state.
* 
* @subsection q_removetask Removing a task
* The qOS_Remove_Task() function removes the task from the scheduling scheme.
* This means the task node will be disconnected from the kernel chain, 
* preventing additional overhead provided by the scheduler when it does checks 
* over it and course, preventing from running.
*
* <b> Caveats: </b>
*
* Task nodes are variables like any other. They allow your application code to 
* reference a task, but there is no link back the other way and the kernel 
* doesn't know anything about the variables, where the variable is allocated 
* (stack, global, static, etc.) or how many copies of the variable you have 
* made, or even if the variable still exists. So the qOS_Remove_Task() API 
* cannot automatically free the resources allocated by the variable. If the task
* node has been dynamically allocated, the application writer it's responsible
* to free the memory block after a removal call.
* 
* @section q_runos Running the OS
* After preparing the multitasking environment for your application, a call to 
* qOS_Run() is required to execute the scheduling scheme. This function is 
* responsible to run the following OS main components:
*
* - <b>The Scheduler</b> : Select the tasks to be submitted into the system and decide 
* with of them are able to run.
* - <b>The Dispatcher</b> : When the scheduler completes its job of selecting ready 
* tasks, it is the dispatcher which takes that task to the running state. This 
* procedure gives a task control over the CPU after it has been selected by the
* scheduler. This involves the following:
*    -# Preparing the resources before the task execution
*    -# Execute the task activities (via the callback function)
*    -# Releasing the resources after the task execution
* 
* The states involved in the interaction between the scheduler and dispatcher 
* are described @ref q_globalstates "here".
* 
* @note  After calling qOS_Run(), the OS scheduler will now be running, and the
* following line should never be reached, however, the user can optionally 
* release it explicitly with qOS_Scheduler_Release() API function.
*
* @subsection q_releasescheduler Releasing the scheduler
* This functionality must be enabled from the @c Q_ALLOW_SCHEDULER_RELEASE 
* macro. This API stop the kernel scheduling. In consequence, the main thread 
* will continue after the qOS_Run() call.
*
* Although producing this action is not a typical desired behavior in any 
* application, it can be used to handle a critical exception.
*
* When used, the release will take place after the current scheduling cycle 
* finish. The kernel can optionally include a release callback function that can
* be configured to get called if the scheduler is released. Defining the release
* callback, will help to take actions over the exception that caused the release
* action. To perform a release action, the qOS_Set_SchedulerReleaseCallback()
* API should be used
*
* @note When a scheduler release is performed, resources are not freed. After
* released, the application can invoke the qOS_Run() again to resume the
* scheduling activities
*
* @section q_globalstates Global states and scheduling rules
* A task can be in one of the four global states: @c qRunning, @c qReady, 
* @c qSuspended or @c qWaiting.
* Each of these states is tracked implicitly by putting the task in one of the 
* associated kernel lists.
*
* These global states are described below:
*
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>globalstates</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-18T13:19:49.977Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;oSuMqHCIxHJLwsXvollB\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;yUrP7yZJVmdYKEqsLdOd\&quot; name=\&quot;Página-1\&quot;&gt;7Vtdb+MoFP01eWxljJ3Yj5O03VlpVqqa3Z2ZfRlRm8ZosEkx+dpfv2DjT5wmzThJs0pbqeYaMNx7OFyOkwGcxOvfOJpHf7AQ04FthesBvBvYNoDAlf+UZaMtwPZyy4yTUNsqw5T8i7XR0tYFCXHaqCgYo4LMm8aAJQkORMOGOGerZrUXRptPnaMZNgzTAFHT+pWEIiqmMfSrG58xmUX60Z49ym/EqKisZ5JGKGSrmgneD+CEMybyq3g9wVR5r/BL3u5hy91yYBwnYp8Gzp//IHbz+9pBkx+vfz/N/uI38Y3uZYnoQk94YA+p7G/8LC9m6qIwvDD5HOVoynhWdfi6YHkF6Fnqt27K274+LZKEJLOiDzm6vJtm19Jce1zmLLEpIsDZIgmxmoQlb68iIvB0jgJ1dyVBJ22RiKksAXmZCs5+4kk5RmhZo4eHBzV8QmlhT1iC9YweUEyoAudnTJdYkACVvRTxtstRLTEXeL3V/6CMqlwPmMVY8I2sUjSwNBD0UoA2zMurCle+rhLVEAW1DWkkz8qeq2DLCx3vd8Te7oh9r773s59f9n2I0igbA+gnEF4zDg6wjThA2BEI4IIjRQIakbgj6RyJIMLciImcuDC8XXjVdDSiZJbIIsUvqpnynHQ0/aTNMQlD1fNYPi+QK/VLVu3OqSxP2gPKxGTzF5qxWCQbYtnDeM5IIjKPuGP5Jx03sW7dgSvHOpFlUJXln6rOxYQlcviIZPHCKBUrnKrBcSaQQM/ZTBXgSsoEGjE1cGnKeQNJTfCauFINp9qvoA9cOQ1c2Z65vr1Trm9n9/rGSfhJbZKyFFCUpiRoLukuF3aRaxkoVS1Y8GW5Xk234zUR33RVdf29dn23rheUI21Xlx4xJ9IvmJeDQVwUg9dYz+eHQ2NLb4VQ+oAteIDf2hi3xLoWTLcjmIWNY4oEWTbH0RVh/YRHtYgqKJWgKPYK6DW7yMevW9U3/VZHwN/RkfTiDAujowxw5bQPx6C7G4MFI31Bz5g+spQIwhQzPTMhWNxBWYK1N54IzVVn8XqmstDbZySBfEvRBnMc/uBZWjjOclKgkMMWgpJE4rjIGC0D6Rk15LkoGL6NfJNWahwsa04m925WsweGsUd+M5rApJgyzajDcngsjhka8X19wijcXHetS9m1bH+4My096bY1ulJGj5Thu81kd3RuxvBMxpgu0jnOXHlljQthjfZh1vHMQ5Q3OiFr+FfW6DPR8ECLNszwnpY2Cj2wzhtfkQyhEpeurHEZrGH78GOxBujSP39FA2uv520hec86p4qvxij4OcuGUmsEoe+X4mYRqJRRNec2PZQP6COO7eNp5znEjKN7tDjuoWXWtA698C9D6Bj0J2roXDA/8+9cFmcTP9qn3EsVP4Cp6/7v2SXboPK86sa3+qEbaLeykQ7F/rR007u0upMrHLdOFv2SVJtxZFj45lu9kA3n1i2KFXtlpWJEPTKVvy9TwfMyVQOX5Uvh9xJVyRTbOjo2Ue0h0x6GZ1DH86072Lb79QfoHkF4XnBBuynMOdaB6Gp3BEfuadFlisR9sWWJqO81rF0KuvakuNFZQQhbIAQHghA4LSESwtOC0JSV000qcDxQH5uRk4SZZIOWiNDsfN2TqBBIXKiN9SordMsKZVmntT19xgO0dO+zv4wHpu6NlzhbITX4BSwJc1mysr0sqMJXf+r4FZJngSR02qeY4V6QdNxjQdLUzBOmABljLGoAFJFkQ6sGzSsMLxiGwG+qKw4cnReGtqns95Ue7iW8ATvLIo93nO4xZ9z3WOx9qJzRsQ88uLQ6gt5+BxcJFbSpVdN0sP0Y77ReZuqX5BWq8x57TUgLv364j+d1iz9vSD9wVClDh2N/J6b9c2K6LSW7oHV8+eiYdu1TYNo2MD0NIhwu6PVzzJfzlrZ8TVJAB5757GT3/R7lQr+p0HWI7f6mAniD4LaEQhar7yLlhFB9pQve/wc=&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>Task global states</em>
* </center>
*
* - @c qWaiting : The task cannot run because the conditions for running are 
* not in place.
* - @c qReady : The task has completed preparations for running, but cannot run 
* because a task with a higher precedence is running.
* - @c qRunning : The task is currently being executed.
* - @c qSuspended : The task doesn't take part in what is going on. Normally 
* this state is taken after the @c qRunning state or when the task does not 
* reach the @c qReady state.
*
* The presence of a task in a particular list indicates the task's state. There
* are many ready-lists as defined in the @c Q_PRIORITY_LEVELS macro. To select 
* the target ready list, the OS use the user-assigned priority between 0 (the 
* lowest priority) and @c Q_PRIORITY_LEVELS-1 (the highest priority). For 
* instance, if @c Q_PRIORITY_LEVELS is set to 5, then QuarkTS will use 5 
* priority levels or ready lists: 0 (lowest priority), 1, 2, 3, and 4 (highest 
* priority).
*
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>oslist</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-18T13:21:59.751Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;qu1SGjoOBtXo91H1rG-O\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;a3gmjD7FvNUACDKGX7UC\&quot; name=\&quot;Página-1\&quot;&gt;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&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>OS lists</em>
* </center>
*
* Except for the idle task, a task exists in one of these states. As the 
* real-time embedded system runs, each task moves from one state to another 
* (moving it from a list to another), according to the logic of a simple finite
* state machine (FSM). The figure above illustrates the typical flowchart used 
* by QuarkTS to handle the task's states, with brief descriptions of state 
* transitions, additionally you may also notice the interaction between the 
* scheduler and the dispatcher.
*
* The OS assumes that none of the tasks does a block anywhere during the 
* @c qRunning state. Based on the round-robin fashion, each ready task runs in 
* turn from every ready lists. The developer should take care to monitor their 
* system execution times to make sure during the worst case, when all tasks have
* to execute, all of the deadlines are still met.
*
* @subsection q_osrules Rules
*
* Task precedence is used as the task scheduling rule and precedence among tasks
* is determined based on the priority of each task. If there are multiple tasks 
* able to run, the one with the highest precedence goes to @c qRunning state 
* first.
*
* In determining precedence among tasks, of those tasks having different 
* priority levels, that with the highest priority has the highest precedence. 
* Among tasks having the same priority, the one that entered the scheduling 
* scheme first has the highest precedence if the @c Q_PRESERVE_TASK_ENTRY_ORDER
* configuration is enabled, otherwise the OS will reserves for himself the order
* according to the dynamics of the kernel lists.
*
* @subsubsection q_os_evenprecedence Event precedence
* The scheduler also has an order of precedence for incoming events, in this 
* way, if events of different nature converge to a single task, these will be 
* served according to the following flowchart:
*
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>evenprecedence</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;zoom&quot;:1.45,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-18T13:23:50.297Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;-HzyQrBmOm1BBi3Kbblc\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;rtI5oX9UaKnuX4kORaYA\&quot; name=\&quot;Página-1\&quot;&gt;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&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>Event precedence</em>
* </center>
*
* @subsubsection q_os_operational_states Additional operational states
* Each task has independent operating states from those globally controlled by 
* the scheduler. These states can be handled by the application writer to modify
* the event-flow to the task and consequently, affecting the transition to the 
* @c qReady global state. These states are described as follows:
*
* - @c qAwake : In this state, the task is conceptually in an alert mode, handling
* most of the available events. This operational state is available when the 
* @c SHUTDOWN bit is set, allowing the next operational states to be available:
*    - @c qEnabled : The task is able to catch all the events. This operational 
* state is available when the @c ENABLE bit is set.
*    - @c qDisabled : In this state the time events will be discarded. This 
* operational state is available when the @c ENABLE bit is cleared.
* - @c qAsleep : Task operability is put into a deep doze mode, so the task 
* can not be triggered by the lower precedence events. This operational state 
* is available when the @c SHUTDOWN bit is cleared. The task can exit from this
* operational state when it receives a high precedence event (a queued 
* notification) or using the qTask_Set_State() API.
* 
* The figure bellow shows a better representation of how the event flow can be 
* affected by this operational states.
*
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>operationalstates</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:150%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;zoom&quot;:1.45,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-18T13:25:47.962Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;9dMBppV9Mj4qN3SqXlf-\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;FMHORikkxHPTSQ5eLvpY\&quot; name=\&quot;Página-1\&quot;&gt;7VrbcqM4EP0aP8bFHfsxdpLNQ+ZS69nKzKMMslGNQA7It/n6bYEAgyDGjokrUyGpMmokIfqcPpIaBuY03P0To1XwhfmYDgzN3w3Mu4Fh6KZuw4+w7KVFN0aZZRkTX9pKw4z8wdKoSeua+DipVOSMUU5WVaPHogh7vGJDccy21WoLRqt3XaElVgwzD1HV+kx8HuSP4YzLC4+YLAN565HhZhdClFeWT5IEyGfbA5N5PzCnMWM8Owt3U0yF93K/ZO0eWq4WA4txxLs0eJruX6I/X54Z5+bE+7EO1t+8G9nLBtG1fODbZB95Qcwitk4GhkOh78k8FuPne+kU52UtBj1ZsIjfJClkt1BB11aA+6S8DmdL+fvZzYfrpt1iVO5hxGwd+ViwTIfL24BwPFshT1zdgiqALeAhlZcXhNIpoyyGcsQiqDRJeMx+49w4MMyRJv7ksNvsMzkAXZYfUEioUJlHTDeYEw8VXeeBa+RNM5XRteJpNjjmeNcaWHoRriB0mIWYx3uoIhtYIxnhUuPMPOK3h4IhbcGBVui61AokRWpZ9F3GMZzIUD4hrA0lrHMcxfNfhiK54WWN14C+NMNw5+3ciRgnC4CGExYlB02yUb0XvzTNfXh46Mgv7Wx+jS5Er3GNXpYxtBWCjRv4Zdh5xYsTzFQIxlHy+xXotOPQvYKTCuqJkHRF+cLS4OZNJHaWpSvIWU4DclpPuFkNwvAWzA6RAd9Op/d2U2Rlx1GMczQSRsVTnAJyH2CZ3cDS+wLLblXxeScJN1oknJOwTbD/EunVL0SJuvZalnN97XUUWjyxLRYLv1WMPezjCAAyNLyBh0wUSMEZXEEmF1UVQUTJMoIixQvRTHgT/E9vpTkkvk9TpIEWJFo+pdXurNLyr/SJMDFovqDpJiiAhhh6mKwYEcOEsdkT+AdXTjVwnQ1jnUJZL8vwL6rHwJsIho9IiiFGCd/iRAwuZhxxNC+4U+y49COEayRYVQffZyXp2lW6uaMGuulG01py1BPb3AvPGIokjNPjzbO8j5KgUKqLYFFbdrmOioTZhITRV+CPjkMBlF+J03C3FAmZIabY47GIWHnKbkLsBShKTXzLntF+tiXcC0SsJ6sshbIgO+HKCabZtRnEFW6hfbvE9zJJO/meKQ8R21JgMd08aiq4mD3BMv6ExXCcmnJZ42vDki/LXsMFR/6tSBJCyaMoSYhXFaumOaDRp/lMI6p563hTKFGbt7Gv5B2P+vrAl3aD8OS2GFPYYG+q3Te5V97hu5iBSyjtWjrDcmrr24StYw/LVocJx1pHjnGkI47iJeZKRynaxWO/gQBqclOdugIWztdJh8XtlePLtoa1CLO1prVB04TU1/5Eb0ozvSnCattJ38Yj37pY5OEd4T/lVXH+SzQDJ2alu53sJS3sZeHDRauu1TcenePVqXVld4tXwBftD6rJFX3rkBVd0LXTxlV90QEn2QguKx5qhutz9ujAR2fstMnUqXx06zyxa6Ppe/7okCz76PIGpIn3Pw8Lv/IeRKFslJZOFUVwVYr1K06WLs2gfKWedVWRraeBjPNF1j1vUXSyyJq17at9RGTr4zLfQ2TVDOf919vJ0/1AhD4IiZmuteaEK4F3ZhrLA4Li+DOR1ZLIGve0SXdk+TCTbqrhavS2F1RzprPH/37cfXv++smzD8yzfEVQ8ExNBrkN04Lh9MWzDtnSgyWDJE0lddm+eCjd5zatGQqAyjl96OjFVC7m9RttqGujI5N7WvqOYwIuERQ+ccY/OpNnon+19akxqm+kHePMqdxSunJrXfW9Qu2QEf6r6XY1FrnO0LTH5VGlge2CK7Ti0M/k11gf6qZZXy4Obc2s3/i9+KamuhMSrqh43dj4ac8bP0dLPy1Ke0D8Yl8jpu9FocKCoqX6evTDvvG+1CvI+tdGefnI+27r9CQjFMuvXzOKlh8Rm/f/Aw==&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>Event flow according operational states</em>
* </center>
*
* @remark Queued notifications are the only event that can wake up sleeping tasks
* @note The @c qAsleep operational state overrides the @c qEnabled and 
* @c qDisabled states.
*
* @section q_critical Critical sections
* Since the kernel is non-preemptive, the only critical section that must be 
* handled are the shared resources accessed from the ISR context. Perhaps, the 
* most obvious way of achieving mutual exclusion is to allow the kernel to 
* disable interrupts before it enters its critical section and then, enable
* interrupts after it leaves its critical section.
*
* By disabling interrupts, the CPU will be unable to change the current context.
* This guarantees that the currently running job can use a shared resource 
* without another context accessing it. But, disabling interrupts, is a major 
* undertaking. At best, the system will not be able to service interrupts for 
* the time the current job is doing in its critical section, however, in QuarkTS,
* these critical sections are handled as quickly as possible.
*
* Considering that the kernel is hardware-independent, the application writer 
* should provide the necessary piece of code to enable and disable interrupts.
*
* For this, the qCritical_SetInterruptsED() API should be used. In this way, 
* communication between ISR and tasks using queued notifications or data queues 
* is performed safely.
*
* In some systems, disabling the global IRQ flags is not enough, as they don't
* save/restore  state of interrupt, so here, the @c qUINT32_t argument and 
* return value in both functions (@c Disabler and @c Restorer) becomes relevant,
* because they can be used by the application writer to save and restore the 
* current interrupt configuration. So, when a critical section is performed, 
* the @c Disabler, in addition to disable the interrupts, returns the current
* configuration to be retained by the kernel, later when the critical section 
* finish, this retained value is passed to @c Restorer to bring back the saved
* configuration.
*
* @section q_configmacros Configuration macros
* Some OS features can be customized using a set of macros located in the header 
* file @c qconfig.h. Here is the default configuration, followed by an 
* explanation of each macro:
*
* - @c Q_PRIORITY_LEVELS : @a Default: @c 3. The number of priorities available for
* application tasks.
* - @c Q_SETUP_TIME_CANONICAL : @a Default: @c 0(disabled). If enabled, the 
* kernel assumes the timing base to 1mS(1KHz). So all time specifications for 
* tasks and STimers must be set in milliseconds(mS). Also can be used to remove
* the floating-point operations when dealing with time. In some systems, 
* can reduce the memory usage.
* - @c Q_SETUP_TICK_IN_HERTZ : @a Default: @c 0(disabled). If enabled, the 
* timing base will be taken as frequency(Hz) instead of period(S) by qOS_Setup()
* (In some systems, can reduce the memory usage ).
* - @c Q_PRIO_QUEUE_SIZE : @a Default: @c 10. Size of the priority queue for 
* notifications. This argument should be an integer number greater than zero. 
* A zero value can be used to disable this functionality.
* - @c Q_PRESERVE_TASK_ENTRY_ORDER : @a Default: @c 0(disabled). If enabled, 
* the kernel will preserve the tasks entry order every OS scheduling cycle.
* - @c Q_MEMORY_MANAGER : @a Default: @c 1(enabled).  Used to enable or disable 
* the @ref q_memmang extension.
* - @c Q_BYTE_ALIGNMENT : @a Default: @c 8. Used by the @ref q_memmang extension 
* to perform the byte-alignment.
* - @c Q_DEFAULT_HEAP_SIZE : @a Default: @c 2048.  The total amount of heap size
* for the default memory pool.
* - @c Q_NOTIFICATION_SPREADER : @a Default: @c 0(disabled). Used to enable or 
* disable the spread notification functionality.
* - @c Q_FSM : @a Default: @c 1(enabled). Used to enable or disable the Finite
State Machine (FSM) extension.
* - @c Q_FSM_MAX_NEST_DEPTH : @a Default: @c 5. The max depth of nesting in
* Finite State Machines (FSM).
* - @c Q_FSM_MAX_TIMEOUTS : @a Default: @c 3. Max number of timeouts inside a 
* timeout specification for the @ref q_fsm extension.
* - @c Q_FSM_PS_SIGNALS_MAX : @a Default: @c 8. Max number of signals to 
* subscribe for a Finite State Machine (FSM).
* - @c Q_FSM_PS_SUB_PER_SIGNAL_MAX : @a Default: @c 4. Max number of FSM
* subscribers per signal.
* - @c Q_QUEUES : @a Default: @c 1(enabled). Used to enable or disable the 
* queues APIs for inter-task communication.
* - @c Q_TRACE_VARIABLES : @a Default: @c 1(enabled). Used to enable or disable 
* debug and trace macros.
* - @c Q_DEBUGTRACE_BUFSIZE : @a Default: @c 36. The buffer size for debug and 
* trace macros
* - @c Q_DEBUGTRACE_FULL : @a Default: @c 1(enabled). Used to enable of disable 
* the extended output for trace macros.
* - @c Q_ATCLI : @a Default: @c 1(enabled). Used to enable or disable the 
* @ref q_atcli extension.
* - @c Q_TASK_COUNT_CYCLES : @a Default: @c 0(disabled). Used to enable or 
* disable the counting of cycler of a task.
* - @c Q_TASK_EVENT_FLAGS : @a Default: @c 1(enabled). Used to enable or disable 
* the task event flags.
* - @c Q_MAX_FTOA_PRECISION : @a Default: @c 10. The default precision used to 
* perform float to ASCII conversions. 
* - @c Q_ATOF_FULL : @a Default: @c 0(disabled). Used to enable or disable the 
* scientific notation in ASCII to float conversions.
* - @c Q_ALLOW_SCHEDULER_RELEASE : @a Default: @c 0(disabled). Used to enable or
* disable the scheduler release functionality.
* - @c Q_RESPONSE_HANDLER : @a Default: @c 1(enabled). Used to enable or disable
* the response handler functionality.
* - @c Q_EDGE_CHECK_IOGROUPS : @a Default: @c 1(enabled). Used to enable or 
* disable the edge check functionality for I/O groups.
* - @c Q_BYTE_SIZED_BUFFERS : @a Default: @c 1(enabled). Used to enable or 
* disable the usage of Byte-sized buffers.
* - @c Q_USE_STDINT_H : @a Default: @c 1(enabled).  Use the @c stdint.h header 
* to define kernel data-types.
*
*/